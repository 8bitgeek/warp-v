\m4_TLV_version 1d: tl-x.org
\SV
   // -----------------------------------------------------------------------------
   // Copyright (c) 2018, Steven F. Hoover
   // 
   // Redistribution and use in source and binary forms, with or without
   // modification, are permitted provided that the following conditions are met:
   // 
   //     * Redistributions of source code must retain the above copyright notice,
   //       this list of conditions and the following disclaimer.
   //     * Redistributions in binary form must reproduce the above copyright
   //       notice, this list of conditions and the following disclaimer in the
   //       documentation and/or other materials provided with the distribution.
   //     * The name Steven F. Hoover
   //       may not be used to endorse or promote products derived from this software
   //       without specific prior written permission.
   // 
   // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
   // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   // -----------------------------------------------------------------------------
   // This code is mastered in https://github.com/stevehoover/warp-v.git


   // A TL-Verilog RISC-V core appropriate for microarchitecture classes.
   //
   // This code was extracted from the TL-Verilog code generated by M4 preprocessing of the 4-stage
   // WARP-V and simplified as follows:
   //   o Loads are single-cycle and write their result directly to the register file without a injecting
   //     a returning load pseudo-instruction.
   //   o Branchs are "predicted" fall-through.
   //   o CSRs were removed.



\TLV riscv_defs()
   // For each opcode[6:2] (op5)
   // (User ISA Manual 2.2, Table 19.1)
   // Associate opcode[6:2] ([1:0] are 2'b11) with mnemonic and instruction type.
   // Instruction type is not in the table, but there seems to be a single instruction type for each of these,
   // so that is mapped here as well.
   // op5(bits, type, mnemonic)
   \SV_plus
      localparam [4:0] OP5_LOAD = 5'b00000;
      localparam [4:0] OP5_LOAD_FP = 5'b00001;
      localparam [4:0] OP5_CUSTOM_0 = 5'b00010;
      localparam [4:0] OP5_MISC_MEM = 5'b00011;
      localparam [4:0] OP5_OP_IMM = 5'b00100;
      localparam [4:0] OP5_AUIPC = 5'b00101;
      localparam [4:0] OP5_OP_IMM_32 = 5'b00110;
      localparam [4:0] OP5_48B1 = 5'b00111;
      localparam [4:0] OP5_STORE = 5'b01000;
      localparam [4:0] OP5_STORE_FP = 5'b01001;
      localparam [4:0] OP5_CUSTOM_1 = 5'b01010;
      localparam [4:0] OP5_AMO = 5'b01011;  // (R-type, but rs2 = const for some, based on funct7 which doesn't exist for I-type?? R-type w/ ignored R2?)
      localparam [4:0] OP5_OP = 5'b01100;
      localparam [4:0] OP5_LUI = 5'b01101;
      localparam [4:0] OP5_OP_32 = 5'b01110;
      localparam [4:0] OP5_64B = 5'b01111;
      localparam [4:0] OP5_MADD = 5'b10000;
      localparam [4:0] OP5_MSUB = 5'b10001;
      localparam [4:0] OP5_NMSUB = 5'b10010;
      localparam [4:0] OP5_NMADD = 5'b10011;
      localparam [4:0] OP5_OP_FP = 5'b10100;  // (R-type, but rs2 = const for some, based on funct7 which doesn't exist for I-type?? R-type w/ ignored R2?)
      localparam [4:0] OP5_RESERVED_1 = 5'b10101;
      localparam [4:0] OP5_CUSTOM_2_RV128 = 5'b10110;
      localparam [4:0] OP5_48B2 = 5'b10111;
      localparam [4:0] OP5_BRANCH = 5'b11000;
      localparam [4:0] OP5_JALR = 5'b11001;
      localparam [4:0] OP5_RESERVED_2 = 5'b11010;
      localparam [4:0] OP5_JAL = 5'b11011;
      localparam [4:0] OP5_SYSTEM = 5'b11100;
      localparam [4:0] OP5_RESERVED_3 = 5'b11101;
      localparam [4:0] OP5_CUSTOM_3_RV128 = 5'b11110;
      localparam [4:0] OP5_80B = 5'b11111;
      
      localparam INSTR_TYPE_I_MASK = 0 | (1 << 5'b00000) | (1 << 5'b00001) | (1 << 5'b00100) | (1 << 5'b00110) | (1 << 5'b11001) | (1 << 5'b11100); localparam INSTR_TYPE_R_MASK = 0 | (1 << 5'b01100) | (1 << 5'b01110); localparam INSTR_TYPE_RI_MASK = 0 | (1 << 5'b01011) | (1 << 5'b10100); localparam INSTR_TYPE_R4_MASK = 0 | (1 << 5'b10000) | (1 << 5'b10001) | (1 << 5'b10010) | (1 << 5'b10011); localparam INSTR_TYPE_S_MASK = 0 | (1 << 5'b01000) | (1 << 5'b01001); localparam INSTR_TYPE_B_MASK = 0 | (1 << 5'b11000); localparam INSTR_TYPE_J_MASK = 0 | (1 << 5'b11011); localparam INSTR_TYPE_U_MASK = 0 | (1 << 5'b00101) | (1 << 5'b01101); localparam INSTR_TYPE___MASK = 0 | (1 << 5'b00010) | (1 << 5'b00011) | (1 << 5'b00111) | (1 << 5'b01010) | (1 << 5'b01111) | (1 << 5'b10101) | (1 << 5'b10110) | (1 << 5'b10111) | (1 << 5'b11010) | (1 << 5'b11101) | (1 << 5'b11110) | (1 << 5'b11111); 
      
      // Instruction characterization.
      // (User ISA Manual 2.2, Table 19.2)
      // instr(type,  // (this is simply verified vs. op5)
      //       |  bit-width,
      //       |  |   extension, 
      //       |  |   |  opcode[6:2],  // (aka op5)
      //       |  |   |  |      func3,   // (if applicable)
      //       |  |   |  |      |    mnemonic)
      localparam [6:0] LUI_INSTR_OPCODE = 7'b0110111;
      localparam [6:0] AUIPC_INSTR_OPCODE = 7'b0010111;
      localparam [6:0] JAL_INSTR_OPCODE = 7'b1101111;
      localparam [6:0] JALR_INSTR_OPCODE = 7'b1100111; localparam [2:0] JALR_INSTR_FUNCT3 = 3'b000;
      localparam [6:0] BEQ_INSTR_OPCODE = 7'b1100011; localparam [2:0] BEQ_INSTR_FUNCT3 = 3'b000;
      localparam [6:0] BNE_INSTR_OPCODE = 7'b1100011; localparam [2:0] BNE_INSTR_FUNCT3 = 3'b001;
      localparam [6:0] BLT_INSTR_OPCODE = 7'b1100011; localparam [2:0] BLT_INSTR_FUNCT3 = 3'b100;
      localparam [6:0] BGE_INSTR_OPCODE = 7'b1100011; localparam [2:0] BGE_INSTR_FUNCT3 = 3'b101;
      localparam [6:0] BLTU_INSTR_OPCODE = 7'b1100011; localparam [2:0] BLTU_INSTR_FUNCT3 = 3'b110;
      localparam [6:0] BGEU_INSTR_OPCODE = 7'b1100011; localparam [2:0] BGEU_INSTR_FUNCT3 = 3'b111;
      localparam [6:0] LB_INSTR_OPCODE = 7'b0000011; localparam [2:0] LB_INSTR_FUNCT3 = 3'b000;
      localparam [6:0] LH_INSTR_OPCODE = 7'b0000011; localparam [2:0] LH_INSTR_FUNCT3 = 3'b001;
      localparam [6:0] LW_INSTR_OPCODE = 7'b0000011; localparam [2:0] LW_INSTR_FUNCT3 = 3'b010;
      localparam [6:0] LBU_INSTR_OPCODE = 7'b0000011; localparam [2:0] LBU_INSTR_FUNCT3 = 3'b100;
      localparam [6:0] LHU_INSTR_OPCODE = 7'b0000011; localparam [2:0] LHU_INSTR_FUNCT3 = 3'b101;
      localparam [6:0] SB_INSTR_OPCODE = 7'b0100011; localparam [2:0] SB_INSTR_FUNCT3 = 3'b000;
      localparam [6:0] SH_INSTR_OPCODE = 7'b0100011; localparam [2:0] SH_INSTR_FUNCT3 = 3'b001;
      localparam [6:0] SW_INSTR_OPCODE = 7'b0100011; localparam [2:0] SW_INSTR_FUNCT3 = 3'b010;
      localparam [6:0] ADDI_INSTR_OPCODE = 7'b0010011; localparam [2:0] ADDI_INSTR_FUNCT3 = 3'b000;
      localparam [6:0] SLTI_INSTR_OPCODE = 7'b0010011; localparam [2:0] SLTI_INSTR_FUNCT3 = 3'b010;
      localparam [6:0] SLTIU_INSTR_OPCODE = 7'b0010011; localparam [2:0] SLTIU_INSTR_FUNCT3 = 3'b011;
      localparam [6:0] XORI_INSTR_OPCODE = 7'b0010011; localparam [2:0] XORI_INSTR_FUNCT3 = 3'b100;
      localparam [6:0] ORI_INSTR_OPCODE = 7'b0010011; localparam [2:0] ORI_INSTR_FUNCT3 = 3'b110;
      localparam [6:0] ANDI_INSTR_OPCODE = 7'b0010011; localparam [2:0] ANDI_INSTR_FUNCT3 = 3'b111;
      localparam [6:0] SLLI_INSTR_OPCODE = 7'b0010011; localparam [2:0] SLLI_INSTR_FUNCT3 = 3'b001;
      localparam [6:0] SRLI_SRAI_INSTR_OPCODE = 7'b0010011; localparam [2:0] SRLI_SRAI_INSTR_FUNCT3 = 3'b101;  // Two instructions distinguished by an immediate bit, treated as a single instruction.
      localparam [6:0] ADD_SUB_INSTR_OPCODE = 7'b0110011; localparam [2:0] ADD_SUB_INSTR_FUNCT3 = 3'b000;  // Treated as a single instruction.
      localparam [6:0] SLL_INSTR_OPCODE = 7'b0110011; localparam [2:0] SLL_INSTR_FUNCT3 = 3'b001;
      localparam [6:0] SLT_INSTR_OPCODE = 7'b0110011; localparam [2:0] SLT_INSTR_FUNCT3 = 3'b010;
      localparam [6:0] SLTU_INSTR_OPCODE = 7'b0110011; localparam [2:0] SLTU_INSTR_FUNCT3 = 3'b011;
      localparam [6:0] XOR_INSTR_OPCODE = 7'b0110011; localparam [2:0] XOR_INSTR_FUNCT3 = 3'b100;
      localparam [6:0] SRL_SRA_INSTR_OPCODE = 7'b0110011; localparam [2:0] SRL_SRA_INSTR_FUNCT3 = 3'b101;  // Treated as a single instruction.
      localparam [6:0] OR_INSTR_OPCODE = 7'b0110011; localparam [2:0] OR_INSTR_FUNCT3 = 3'b110;
      localparam [6:0] AND_INSTR_OPCODE = 7'b0110011; localparam [2:0] AND_INSTR_FUNCT3 = 3'b111;
   
\SV
   m4_makerchip_module

   // Instruction memory and fetch of $raw.
                  
      // /=====================\
      // | Count to 10 Program |
      // \=====================/
      //

      // Add 1,2,3,...,9 (in that order).
      // Store incremental results in memory locations 0..9. (1, 3, 6, 10, ...)
      //
      // Regs:
      // 1: cnt
      // 2: ten
      // 3: out
      // 4: tmp
      // 5: offset
      // 6: store addr

      // Inst #0: ORI,r6,r0,0        //     store_addr = 0
      // Inst #1: ORI,r1,r0,1        //     cnt = 1
      // Inst #2: ORI,r2,r0,1010     //     ten = 10
      // Inst #3: ORI,r3,r0,0        //     out = 0
      // Inst #4: ADD,r3,r1,r3       //  -> out += cnt
      // Inst #5: SW,r6,r3,0         //     store out at store_addr
      // Inst #6: ADDI,r1,r1,1       //     cnt ++
      // Inst #7: ADDI,r6,r6,100     //     store_addr++
      // Inst #8: BLT,r1,r2,1111111110000 //  ^- branch back if cnt < 10
      // Inst #9: LW,r4,r6,111111111100 //     load the final value into tmp
      // Inst #10: BGE,r1,r2,1111111010100 //     TERMINATE by branching to -1

   // ==============
   // IMem and Fetch
   // ==============

   // For simulation
   // --------------

   // (Vivado doesn't like this)
   // The program in an instruction memory.
   logic [31:0] instrs [0:11-1];

   assign instrs = '{
      {12'b0, 5'd0, ORI_INSTR_FUNCT3, 5'd6, ORI_INSTR_OPCODE},
      {12'b1, 5'd0, ORI_INSTR_FUNCT3, 5'd1, ORI_INSTR_OPCODE},
      {12'b1010, 5'd0, ORI_INSTR_FUNCT3, 5'd2, ORI_INSTR_OPCODE},
      {12'b0, 5'd0, ORI_INSTR_FUNCT3, 5'd3, ORI_INSTR_OPCODE},
      {7'b0, 5'd3, 5'd1, ADD_SUB_INSTR_FUNCT3, 5'd3, ADD_SUB_INSTR_OPCODE},
      {7'b0000000, 5'd3, 5'd6, SW_INSTR_FUNCT3, 5'b00000, SW_INSTR_OPCODE},
      {12'b1, 5'd1, ADDI_INSTR_FUNCT3, 5'd1, ADDI_INSTR_OPCODE},
      {12'b100, 5'd6, ADDI_INSTR_FUNCT3, 5'd6, ADDI_INSTR_OPCODE},
      {1'b1, 6'b111111, 5'd2, 5'd1, BLT_INSTR_FUNCT3, 4'b1000, 1'b1, BLT_INSTR_OPCODE},
      {12'b111111111100, 5'd6, LW_INSTR_FUNCT3, 5'd4, LW_INSTR_OPCODE},
      {1'b1, 6'b111110, 5'd2, 5'd1, BGE_INSTR_FUNCT3, 4'b1010, 1'b1, BGE_INSTR_OPCODE}
   };
\TLV
   /* verilator lint_on WIDTH */  // Let's be strict about bit widths.

   m4+riscv_defs()

   |fetch
      /instr
         @0
            ?$fetch
               $raw[31:0] = *instrs\[$Pc[5:2]\];
      

   // /=========\
   // | The CPU |
   // \=========/

   |fetch
      /instr
         @-1
            $reset = *reset;

         @0
            $fetch = ! $reset;  // always fetch
            // (M4_IMEM_MACRO_NAME instantiation produces ?$fetch$raw.)
         @0

            // ========
            // Overview
            // ========

            // Redirect Shadow
            // A mask of stages ahead of this one (older) in which instructions are on the path of this instruction.
            // Index 1 is ahead by 1, etc.
            // In the example above, $GoodPathMask for Redir'edX == {0,0,0,0,1,1,0,0}
            //     (Looking up in the waterfall diagram from its first "o", in reverse order {o,X,o,o,y,y,o,o}.)
            // The LSB is fetch-valid. It only exists for m4_prev_instr_valid_through macro.
            $next_good_path_mask[3+1:0] =
               // Shift up and mask w/ redirect conditions.
               {$GoodPathMask[3:0]
                // & terms for each condition (order doesn't matter since masks are the same within a cycle)
                    & ((>>2$jump && $GoodPathMask[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}})
                    & ((>>2$mispred_branch && $GoodPathMask[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}})
                    & ((>>2$indirect_jump && $GoodPathMask[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}),
                 1'b1}; // Shift in 1'b1 (fetch-valid).

            $GoodPathMask[3+1:0] <=
               <<1$reset ? 5'b0 :  // All bad-path (through self) on reset (next mask based on next reset).
               $next_good_path_mask;

            // Next PC
            $pc_inc[31:2] = $Pc + 30'b1;
            $Pc[31:2] <=
               $reset ? 30'b0 :
               // ? : terms for each condition (order does matter)
               (>>2$indirect_jump && $GoodPathMask[2]) ? >>2$indirect_jump_target :
               (>>2$mispred_branch && $GoodPathMask[2]) ? >>2$branch_target :
               (>>2$jump && $GoodPathMask[2]) ? >>2$jump_target :
                        $pc_inc;

         @1

            // ======
            // DECODE
            // ======

            // Decode of the fetched instruction
            $valid_decode = $fetch;  // Always decode if we fetch.
            $valid_decode_branch = $valid_decode && $branch;
            // A load that will return later.
            //$split_ld = $spec_ld && 1'b['']M4_INJECT_RETURNING_LD;
            // TODO: ?$valid_<stage> conditioning should be replaced by use of m4_prev_instr_valid_through(..).
            ?$valid_decode

               // =================================

               // Extract fields of $raw (instruction) into $raw_<field>[x:0].
               {$raw_funct7[6:0], $raw_rs2[4:0], $raw_rs1[4:0], $raw_funct3[2:0], $raw_rd[4:0], $raw_op5[4:0], $raw_op2[1:0]} = $raw;
               `BOGUS_USE($raw_op2)  // Delete once it's used.
               // Extract immediate fields into type-specific signals.
               // (User ISA Manual 2.2, Fig. 2.4)
               $raw_i_imm[31:0] = {{21{$raw[31]}}, $raw[30:20]};
               $raw_s_imm[31:0] = {{21{$raw[31]}}, $raw[30:25], $raw[11:7]};
               $raw_b_imm[31:0] = {{20{$raw[31]}}, $raw[7], $raw[30:25], $raw[11:8], 1'b0};
               $raw_u_imm[31:0] = {$raw[31:12], {12{1'b0}}};
               $raw_j_imm[31:0] = {{12{$raw[31]}}, $raw[19:12], $raw[20], $raw[30:21], 1'b0};
               // Extract other type/instruction-specific fields.
               $raw_shamt[6:0] = $raw[26:20];
               $raw_aq = $raw[26];
               $raw_rl = $raw[25];
               $raw_rs3[4:0] = $raw[31:27];
               $raw_rm[2:0] = $raw_funct3;
               `BOGUS_USE($raw_shamt $raw_aq $raw_rl $raw_rs3 $raw_rm)  // Avoid "unused" messages. Remove these as they become used.

               // Instruction type decode
               $is_i_type = INSTR_TYPE_I_MASK[$raw_op5];
               $is_r_type = INSTR_TYPE_R_MASK[$raw_op5];
               $is_ri_type = INSTR_TYPE_RI_MASK[$raw_op5];
               $is_r4_type = INSTR_TYPE_R4_MASK[$raw_op5];
               $is_s_type = INSTR_TYPE_S_MASK[$raw_op5];
               $is_b_type = INSTR_TYPE_B_MASK[$raw_op5];
               $is_j_type = INSTR_TYPE_J_MASK[$raw_op5];
               $is_u_type = INSTR_TYPE_U_MASK[$raw_op5];
               $is___type = INSTR_TYPE___MASK[$raw_op5]; 

               // Instruction decode.
               $is_lui_instr = $raw_op5 == 5'b01101;
               $is_auipc_instr = $raw_op5 == 5'b00101;
               $is_jal_instr = $raw_op5 == 5'b11011;
               $is_jalr_instr = $raw_op5 == 5'b11001 && $raw_funct3 == 3'b000;
               $is_beq_instr = $raw_op5 == 5'b11000 && $raw_funct3 == 3'b000;
               $is_bne_instr = $raw_op5 == 5'b11000 && $raw_funct3 == 3'b001;
               $is_blt_instr = $raw_op5 == 5'b11000 && $raw_funct3 == 3'b100;
               $is_bge_instr = $raw_op5 == 5'b11000 && $raw_funct3 == 3'b101;
               $is_bltu_instr = $raw_op5 == 5'b11000 && $raw_funct3 == 3'b110;
               $is_bgeu_instr = $raw_op5 == 5'b11000 && $raw_funct3 == 3'b111;
               $is_lb_instr = $raw_op5 == 5'b00000 && $raw_funct3 == 3'b000;
               $is_lh_instr = $raw_op5 == 5'b00000 && $raw_funct3 == 3'b001;
               $is_lw_instr = $raw_op5 == 5'b00000 && $raw_funct3 == 3'b010;
               $is_lbu_instr = $raw_op5 == 5'b00000 && $raw_funct3 == 3'b100;
               $is_lhu_instr = $raw_op5 == 5'b00000 && $raw_funct3 == 3'b101;
               $is_sb_instr = $raw_op5 == 5'b01000 && $raw_funct3 == 3'b000;
               $is_sh_instr = $raw_op5 == 5'b01000 && $raw_funct3 == 3'b001;
               $is_sw_instr = $raw_op5 == 5'b01000 && $raw_funct3 == 3'b010;
               $is_addi_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b000;
               $is_slti_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b010;
               $is_sltiu_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b011;
               $is_xori_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b100;
               $is_ori_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b110;
               $is_andi_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b111;
               $is_slli_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b001;
               $is_srli_srai_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b101;
               $is_add_sub_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b000;
               $is_sll_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b001;
               $is_slt_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b010;
               $is_sltu_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b011;
               $is_xor_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b100;
               $is_srl_sra_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b101;
               $is_or_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b110;
               $is_and_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b111;

               $illegal = 1'b1 && ! $is_lui_instr && ! $is_auipc_instr && ! $is_jal_instr && ! $is_jalr_instr && ! $is_beq_instr && ! $is_bne_instr && ! $is_blt_instr && ! $is_bge_instr && ! $is_bltu_instr && ! $is_bgeu_instr && ! $is_lb_instr && ! $is_lh_instr && ! $is_lw_instr && ! $is_lbu_instr && ! $is_lhu_instr && ! $is_sb_instr && ! $is_sh_instr && ! $is_sw_instr && ! $is_addi_instr && ! $is_slti_instr && ! $is_sltiu_instr && ! $is_xori_instr && ! $is_ori_instr && ! $is_andi_instr && ! $is_slli_instr && ! $is_srli_srai_instr && ! $is_add_sub_instr && ! $is_sll_instr && ! $is_slt_instr && ! $is_sltu_instr && ! $is_xor_instr && ! $is_srl_sra_instr && ! $is_or_instr && ! $is_and_instr;
               $conditional_branch = $is_b_type;
            $jump = $is_jal_instr;  // "Jump" in RISC-V means unconditional. (JALR is a separate redirect condition.)
            $branch = $is_b_type;
            $indirect_jump = $is_jalr_instr;
            ?$valid_decode
               $ld = $raw[6:3] == 4'b0;
               $st = $is_s_type;
               $ld_st = $ld || $st;
               //$ld_st_byte = $ld_st && ($raw_funct3[1:0] == 2'b00);
               `BOGUS_USE($is___type $is_u_type)

               // Output signals.
               /src[2:1]
                  // Reg valid for this source, based on instruction type.
                  $is_reg = /instr$is_r_type || /instr$is_r4_type || (/instr$is_i_type && (#src == 1)) || /instr$is_ri_type || /instr$is_s_type || /instr$is_b_type;
                  $reg[4:0] = (#src == 1) ? /instr$raw_rs1 : /instr$raw_rs2;

            // Condition signals must not themselves be conditioned (currently).
            $dest_reg[4:0] = $raw_rd;
            $dest_reg_valid = ($valid_decode && ! $is_s_type && ! $is_b_type) &&
                              | $dest_reg;   // r0 not valid.
            // Actually load.
            $spec_ld = $valid_decode && $ld;

         @1

            // Pending value to write to dest reg. Loads (not replaced by returning ld) write pending.
            $reg_wr_pending = $ld;
            `BOGUS_USE($reg_wr_pending)  // Not used if no bypass and no pending.

            // ======
            // Reg Rd
            // ======

            // Obtain source register values and pending bit for source registers. Bypass up to 3
            // stages.
            // It is not necessary to bypass pending, as we could delay the replay, but we implement
            // bypass for performance.
            // Pending has an additional read for the dest register as we need to replay for write-after-write
            // hazard as well as write-after-read. To replay for dest write with the same timing, we must also
            // bypass the dest reg's pending bit.
            /regs[31:1]
            /src[2:1]
               $is_reg_condition = $is_reg && /instr$valid_decode;  // Note: $is_reg can be set for RISC-V sr0.
               ?$is_reg_condition
                  $reg_value[31:0] =
                     ($reg == 5'b0) ? 32'b0 :  // Read r0 as 0 (not pending).
                     // Bypass stages. Both register and pending are bypassed.
                     // Bypassed registers must be from instructions that are good-path as of this instruction or are returning_ld.
                     (/instr>>1$dest_reg_valid && (/instr$GoodPathMask[1]) && (/instr>>1$dest_reg == $reg)) ? /instr>>1$rslt :
                     (/instr>>2$dest_reg_valid && (/instr$GoodPathMask[2]) && (/instr>>2$dest_reg == $reg)) ? /instr>>2$rslt :
                     /instr/regs[$reg]>>2$value;

         // =======
         // Execute
         // =======
         @1
            ?$valid_decode_branch
               $branch_target[31:2] = $Pc[31:2] + $raw_b_imm[31:2];
            ?$jump  // (JAL, not JALR)
               $jump_target[31:2] = $Pc[31:2] + $raw_j_imm[31:2];
         @2
            // Execution.
            $valid_exe = $valid_decode; // Execute if we decoded.

            // Compute results for each instruction, independent of decode (power-hungry, but fast).
            ?$valid_exe
               $equal = /src[1]$reg_value == /src[2]$reg_value;
            ?$branch
               $taken =
                  $is_j_type ||
                  ($is_beq_instr && $equal) ||
                  ($is_bne_instr && ! $equal) ||
                  (($is_blt_instr || $is_bltu_instr || $is_bge_instr || $is_bgeu_instr) &&
                   (($is_bge_instr || $is_bgeu_instr) ^
                    (({($is_blt_instr ^ /src[1]$reg_value[31]), /src[1]$reg_value[31-1:0]} <
                      {($is_blt_instr ^ /src[2]$reg_value[31]), /src[2]$reg_value[31-1:0]}
                     ) ^ ((/src[1]$reg_value[31] != /src[2]$reg_value[31]) & $is_bge_instr)
                    )
                   )
                  );
            ?$indirect_jump  // (JALR)
               $indirect_jump_full_target[31:0] = /src[1]$reg_value + $raw_i_imm;
               $indirect_jump_target[31:2] = $indirect_jump_full_target[31:2];
            ?$valid_exe
               // Compute each individual instruction result, combined per-instruction by a macro.

               $lui_rslt[31:0] = {$raw_u_imm[31:12], 12'b0};
               $auipc_rslt[31:0] = {$Pc, 2'b0} + $raw_u_imm;
               $jal_rslt[31:0] = {$Pc, 2'b0} + 4;
               $jalr_rslt[31:0] = {$Pc, 2'b0} + 4;
               // Load instructions. If returning ld is enabled, load instructions write no meaningful result, so we use zeros.

               $lb_rslt[31:0] = 32'b0;
               $lh_rslt[31:0] = 32'b0;
               $lw_rslt[31:0] = 32'b0;
               $lbu_rslt[31:0] = 32'b0;
               $lhu_rslt[31:0] = 32'b0;

               $addi_rslt[31:0] = /src[1]$reg_value + $raw_i_imm;  // Note: this has its own adder; could share w/ add/sub.
               $xori_rslt[31:0] = /src[1]$reg_value ^ $raw_i_imm;
               $ori_rslt[31:0] = /src[1]$reg_value | $raw_i_imm;
               $andi_rslt[31:0] = /src[1]$reg_value & $raw_i_imm;
               $slli_rslt[31:0] = /src[1]$reg_value << $raw_i_imm[5:0];
               $srli_intermediate_rslt[31:0] = /src[1]$reg_value >> $raw_i_imm[5:0];
               $srai_intermediate_rslt[31:0] = /src[1]$reg_value[31] ? $srli_intermediate_rslt | ((32'b0 - 1) << (32 - $raw_i_imm[5:0]) ): $srli_intermediate_rslt;
               $sra_intermediate_rslt[31:0] = /src[1]$reg_value[31] ? $srl_intermediate_rslt | ((32'b0 - 1) << (32 - /src[2]$reg_value[4:0]) ): $srl_intermediate_rslt;
               $srl_intermediate_rslt[31:0] = /src[1]$reg_value >> /src[2]$reg_value[4:0];
               $slti_rslt[31:0] =  (/src[1]$reg_value[31] == $raw_i_imm[31]) ? $sltiu_rslt : {31'b0,/src[1]$reg_value[31]};
               $sltiu_rslt[31:0] = (/src[1]$reg_value < $raw_i_imm) ? 1 : 0;
               $srli_srai_rslt[31:0] = ($raw_i_imm[10] == 1) ? $srai_intermediate_rslt : $srli_intermediate_rslt;
               $add_sub_rslt[31:0] =  ($raw_funct7[5] == 1) ?  /src[1]$reg_value - /src[2]$reg_value : /src[1]$reg_value + /src[2]$reg_value;
               $sll_rslt[31:0] = /src[1]$reg_value << /src[2]$reg_value[4:0];
               $slt_rslt[31:0] = (/src[1]$reg_value[31] == /src[2]$reg_value[31]) ? $sltu_rslt : {31'b0,/src[1]$reg_value[31]};
               $sltu_rslt[31:0] = (/src[1]$reg_value < /src[2]$reg_value) ? 1 : 0;
               $xor_rslt[31:0] = /src[1]$reg_value ^ /src[2]$reg_value;
               $srl_sra_rslt[31:0] = ($raw_funct7[5] == 1) ? $sra_intermediate_rslt : $srl_intermediate_rslt;
               $or_rslt[31:0] = /src[1]$reg_value | /src[2]$reg_value;
               $and_rslt[31:0] = /src[1]$reg_value & /src[2]$reg_value;

         @2
            // Memory inputs.
            $ld_st_cond = $ld_st && $valid_exe;
            ?$ld_st_cond
               $addr[31:0] = /src[1]$reg_value + ($ld ? $raw_i_imm : $raw_s_imm);

            $st_cond = $st && $valid_exe;
            ?$st_cond
               // Provide a value to store, naturally-aligned to memory, that will work regardless of the lower $addr bits.
               $st_reg_value[31:0] = /src[2]$reg_value;
               $st_value[31:0] = $st_reg_value;

         @2
            // Mux the correct result.
            $rslt[31:0] =
                ({32{$ld}} & $ld_value) |
                ({32{$is_lui_instr}} & $lui_rslt) |
                ({32{$is_auipc_instr}} & $auipc_rslt) |
                ({32{$is_jal_instr}} & $jal_rslt) |
                ({32{$is_jalr_instr}} & $jalr_rslt) |
                ({32{$is_lb_instr}} & $lb_rslt) |
                ({32{$is_lh_instr}} & $lh_rslt) |
                ({32{$is_lw_instr}} & $lw_rslt) |
                ({32{$is_lbu_instr}} & $lbu_rslt) |
                ({32{$is_lhu_instr}} & $lhu_rslt) |
                ({32{$is_addi_instr}} & $addi_rslt) |
                ({32{$is_slti_instr}} & $slti_rslt) |
                ({32{$is_sltiu_instr}} & $sltiu_rslt) |
                ({32{$is_xori_instr}} & $xori_rslt) |
                ({32{$is_ori_instr}} & $ori_rslt) |
                ({32{$is_andi_instr}} & $andi_rslt) |
                ({32{$is_slli_instr}} & $slli_rslt) |
                ({32{$is_srli_srai_instr}} & $srli_srai_rslt) |
                ({32{$is_add_sub_instr}} & $add_sub_rslt) |
                ({32{$is_sll_instr}} & $sll_rslt) |
                ({32{$is_slt_instr}} & $slt_rslt) |
                ({32{$is_sltu_instr}} & $sltu_rslt) |
                ({32{$is_xor_instr}} & $xor_rslt) |
                ({32{$is_srl_sra_instr}} & $srl_sra_rslt) |
                ({32{$is_or_instr}} & $or_rslt) |
                ({32{$is_and_instr}} & $and_rslt);

         @2

            // =======
            // Control
            // =======

            // Execute stage redirect conditions.
            $mispred_branch = $branch && ! ($conditional_branch && ! $taken);

            // Commit: Ultimate decision to commit results of this instruction.

            // Normal case:
            $commit = ! $reset && >>-2$next_good_path_mask[3];


            // Conditions that commit results.
            $valid_dest_reg_valid = ($dest_reg_valid && $commit);
            $valid_st = $st && $commit;

   // This macro assumes little-endian.

   |fetch
      /instr
         // ====
         // Load
         // ====
         @2
            /mem[31:0]
            ?$spec_ld
               $ld_value[31:0] = /mem[$addr[4 + 2 : 2]]$Value;

            // Array writes are not currently permitted to use assignment
            // syntax, so \always_comb is used, and this must be outside of
            // when conditions, so we need to use if. <<1 because no <= support
            // in this context. (This limitation will be lifted.)

            // =====
            // Store
            // =====

            \SV_plus
               always @ (posedge clk) begin
                  if ($valid_st)
                     /mem[$addr[4 + 2 : 2]]<<0$$Value[31 : 0] <= $st_value;
               end

   |fetch
      /instr
         @3
            // =========
            // Reg Write
            // =========

            $reg_write = $reset ? 1'b0 : $valid_dest_reg_valid;
            \SV_plus
               always @ (posedge clk) begin
                  if ($reg_write)
                     /regs[$dest_reg]<<0$$value[31:0] <= $rslt;
               end

            // Write $pending along with $value, but coded differently because it must be reset.
            /regs[*]
               <<1$pending = ! /instr$reset && (((#regs == /instr$dest_reg) && /instr$valid_dest_reg_valid) ? /instr$reg_wr_pending : $pending);

   |fetch
      /instr
         @3
            // Assert these to end simulation (before Makerchip cycle limit).
            $ReachedEnd <= $reset ? 1'b0 : $ReachedEnd || $Pc == {30{1'b1}};
            $Reg4Became45 <= $reset ? 1'b0 : $Reg4Became45 || ($ReachedEnd && /regs[4]$value == 32'd45);
            *passed = ! $reset && $ReachedEnd && $Reg4Became45;
            *failed = ! $reset && (*cyc_cnt > 200 || (*cyc_cnt > 5 && $commit && $illegal));
   
\SV
   endmodule

