\TLV_version [\source warp-v.tlv] 1d: tl-x.org
\SV
   // -----------------------------------------------------------------------------
   // Copyright (c) 2017, Steven F. Hoover
   // 
   // Redistribution and use in source and binary forms, with or without
   // modification, are permitted provided that the following conditions are met:
   // 
   //     * Redistributions of source code must retain the above copyright notice,
   //       this list of conditions and the following disclaimer.
   //     * Redistributions in binary form must reproduce the above copyright
   //       notice, this list of conditions and the following disclaimer in the
   //       documentation and/or other materials provided with the distribution.
   //     * The name Steven F. Hoover
   //       may not be used to endorse or promote products derived from this software
   //       without specific prior written permission.
   // 
   // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
   // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   // -----------------------------------------------------------------------------
     // 0 to disable code for formal verificatio.
    //

   // This code is mastered in https://github.com/stevehoover/warp-v.git


\SV
   
   module warpv(input logic clk, input logic reset, output logic failed, output logic passed,
            output logic  rvfi_valid, 
            output logic [31:0] rvfi_insn,
            output logic [63 : 0] rvfi_order,
            output logic rvfi_halt,
            output logic rvfi_trap,       
            output logic rvfi_halt,       
            output logic rvfi_intr,       
            output logic [4: 0] rvfi_rs1_addr,   
            output logic [4: 0] rvfi_rs2_addr,   
            output logic [31: 0] rvfi_rs1_rdata,  
            output logic [31: 0] rvfi_rs2_rdata,  
            output logic [4: 0] rvfi_rd_addr,    
            output logic [31: 0] rvfi_rd_wdata,   
            output logic [31:0] rvfi_pc_rdata,   
            output logic [31:0] rvfi_pc_wdata ,   
            output logic [31:0] rvfi_mem_addr,   
            output logic [3: 0] rvfi_mem_rmask,  
            output logic [3: 0] rvfi_mem_wmask,  
            output logic [31: 0] rvfi_mem_rdata,  
            output logic [31: 0] rvfi_mem_wdata);
\SV
\source warp-v.tlv 617
\SV
/* verilator lint_on WIDTH */  // Let's be strict about bit widths.






\source warp-v.tlv 1476

\SV_plus
 (* keep *)   reg [63:0] rvfi_order_reg;
always @(posedge clk)
begin
   rvfi_order_reg      <= reset ? 0 : rvfi_order_reg + rvfi_valid;
end

   
   
\TLV 
   
   //RVFI interface for formal verification
   *rvfi_valid       = |fetch/instr>>0$retire && !|fetch/instr>>0$returning_ld; //
   *rvfi_insn        = |fetch/instr>>0$raw;
   *rvfi_halt        = |fetch/instr>>0$illegal;
   *rvfi_trap        = |fetch/instr>>0$trap;
   *rvfi_order       = *rvfi_order_reg;
   *rvfi_intr        = 1'b0;
   *rvfi_rs1_addr    = |fetch/instr$is_u_type ? 0 : |fetch/instr$raw_rs1;
   *rvfi_rs2_addr    = (|fetch/instr$is_i_type | |fetch/instr$is_u_type) ? 0 : |fetch/instr$raw_rs2;
   *rvfi_rs1_rdata   = |fetch/instr/src[1]$reg_value;
   *rvfi_rs2_rdata   = |fetch/instr/src[2]$reg_value;
   *rvfi_rd_addr     = |fetch/instr$is_s_type ? 0 : |fetch/instr$raw_rd;
   *rvfi_rd_wdata    = *rvfi_rd_addr  ? |fetch/instr$rslt : 0;
   *rvfi_pc_rdata    = |fetch/instr$Pc[31:2];
   *rvfi_pc_wdata    = |fetch/instr$Pc[31:2] + 4'd4;
   *rvfi_mem_addr    = |fetch/instr$addr[31:0];
   *rvfi_mem_rmask   = (|fetch/instr$ld ) ? 4'b1111 : 4'b0000;
   *rvfi_mem_wmask   = |fetch/instr>>0$valid_st ? 4'b1111 : 4'b0000;
   *rvfi_mem_rdata   = /top|mem/data>>1$ld_rslt;
   *rvfi_mem_wdata   = |fetch/instr$st_value;
   


\TLV
   // =================
   //
   //    THE MODEL
   //
   // =================
   
   \source warp-v.tlv 1291   // Instantiated from warp-v.tlv, 1519 as: m4+cpu()
      
      // Generated logic
      \source warp-v.tlv 867   // Instantiated from warp-v.tlv, 1294 as: m4+indirect(M4_isa['_gen'])
         
         // v---------------------
         // Instruction characterization
      
         // M4 ugliness for instruction characterization.
         
         // For each opcode[6:2]
         // (User ISA Manual 2.2, Table 19.1)
         // Associate opcode[6:2] ([1:0] are 2'b11) with mnemonic and instruction type.
         // Instruction type is not in the table, but there seems to be a single instruction type for each of these,
         // so that is mapped here as well.
         // op5(bits, type, mnemonic)
         \SV_plus
            localparam [4:0] OP5_LOAD = 5'b00000;
            localparam [4:0] OP5_LOAD_FP = 5'b00001;
            localparam [4:0] OP5_CUSTOM_0 = 5'b00010;
            localparam [4:0] OP5_MISC_MEM = 5'b00011;
            localparam [4:0] OP5_OP_IMM = 5'b00100;
            localparam [4:0] OP5_AUIPC = 5'b00101;
            localparam [4:0] OP5_OP_IMM_32 = 5'b00110;
            localparam [4:0] OP5_48B1 = 5'b00111;
            localparam [4:0] OP5_STORE = 5'b01000;
            localparam [4:0] OP5_STORE_FP = 5'b01001;
            localparam [4:0] OP5_CUSTOM_1 = 5'b01010;
            localparam [4:0] OP5_AMO = 5'b01011;  // (R-type, but rs2 = const for some, based on funct7 which doesn't exist for I-type?? R-type w/ ignored R2?)
            localparam [4:0] OP5_OP = 5'b01100;
            localparam [4:0] OP5_LUI = 5'b01101;
            localparam [4:0] OP5_OP_32 = 5'b01110;
            localparam [4:0] OP5_64B = 5'b01111;
            localparam [4:0] OP5_MADD = 5'b10000;
            localparam [4:0] OP5_MSUB = 5'b10001;
            localparam [4:0] OP5_NMSUB = 5'b10010;
            localparam [4:0] OP5_NMADD = 5'b10011;
            localparam [4:0] OP5_OP_FP = 5'b10100;  // (R-type, but rs2 = const for some, based on funct7 which doesn't exist for I-type?? R-type w/ ignored R2?)
            localparam [4:0] OP5_RESERVED_1 = 5'b10101;
            localparam [4:0] OP5_CUSTOM_2_RV128 = 5'b10110;
            localparam [4:0] OP5_48B2 = 5'b10111;
            localparam [4:0] OP5_BRANCH = 5'b11000;
            localparam [4:0] OP5_JALR = 5'b11001;
            localparam [4:0] OP5_RESERVED_2 = 5'b11010;
            localparam [4:0] OP5_JAL = 5'b11011;
            localparam [4:0] OP5_SYSTEM = 5'b11100;
            localparam [4:0] OP5_RESERVED_3 = 5'b11101;
            localparam [4:0] OP5_CUSTOM_3_RV128 = 5'b11110;
            localparam [4:0] OP5_80B = 5'b11111;
            
         \SV_plus
            // Not sure these are ever used.
            localparam INSTR_TYPE_I_MASK = 0 | (1 << 5'b00000) | (1 << 5'b00001) | (1 << 5'b00100) | (1 << 5'b00110) | (1 << 5'b11001); localparam INSTR_TYPE_R_MASK = 0 | (1 << 5'b01100) | (1 << 5'b01110); localparam INSTR_TYPE_RI_MASK = 0 | (1 << 5'b01011) | (1 << 5'b10100); localparam INSTR_TYPE_R4_MASK = 0 | (1 << 5'b10000) | (1 << 5'b10001) | (1 << 5'b10010) | (1 << 5'b10011); localparam INSTR_TYPE_S_MASK = 0 | (1 << 5'b01000) | (1 << 5'b01001); localparam INSTR_TYPE_B_MASK = 0 | (1 << 5'b11000); localparam INSTR_TYPE_J_MASK = 0 | (1 << 5'b11011); localparam INSTR_TYPE_U_MASK = 0 | (1 << 5'b00101) | (1 << 5'b01101); localparam INSTR_TYPE___MASK = 0 | (1 << 5'b00010) | (1 << 5'b00011) | (1 << 5'b00111) | (1 << 5'b01010) | (1 << 5'b01111) | (1 << 5'b10101) | (1 << 5'b10110) | (1 << 5'b10111) | (1 << 5'b11010) | (1 << 5'b11100) | (1 << 5'b11101) | (1 << 5'b11110) | (1 << 5'b11111); 
            
         \SV_plus
            // Instruction characterization.
            // (User ISA Manual 2.2, Table 19.2)
            // instr(type,  // (this is simply verified vs. op5)
            //       |  bit-width,
            //       |  |   extension, 
            //       |  |   |  opcode[6:2],  // (aka op5)
            //       |  |   |  |      func3,   // (if applicable)
            //       |  |   |  |      |    mnemonic)
            localparam [6:0] LUI_INSTR_OPCODE = 7'b0110111;
            localparam [6:0] AUIPC_INSTR_OPCODE = 7'b0010111;
            localparam [6:0] JAL_INSTR_OPCODE = 7'b1101111;
            localparam [6:0] JALR_INSTR_OPCODE = 7'b1100111; localparam [2:0] JALR_INSTR_FUNCT3 = 3'b000;
            localparam [6:0] BEQ_INSTR_OPCODE = 7'b1100011; localparam [2:0] BEQ_INSTR_FUNCT3 = 3'b000;
            localparam [6:0] BNE_INSTR_OPCODE = 7'b1100011; localparam [2:0] BNE_INSTR_FUNCT3 = 3'b001;
            localparam [6:0] BLT_INSTR_OPCODE = 7'b1100011; localparam [2:0] BLT_INSTR_FUNCT3 = 3'b100;
            localparam [6:0] BGE_INSTR_OPCODE = 7'b1100011; localparam [2:0] BGE_INSTR_FUNCT3 = 3'b101;
            localparam [6:0] BLTU_INSTR_OPCODE = 7'b1100011; localparam [2:0] BLTU_INSTR_FUNCT3 = 3'b110;
            localparam [6:0] BGEU_INSTR_OPCODE = 7'b1100011; localparam [2:0] BGEU_INSTR_FUNCT3 = 3'b111;
            localparam [6:0] LB_INSTR_OPCODE = 7'b0000011; localparam [2:0] LB_INSTR_FUNCT3 = 3'b000;
            localparam [6:0] LH_INSTR_OPCODE = 7'b0000011; localparam [2:0] LH_INSTR_FUNCT3 = 3'b001;
            localparam [6:0] LW_INSTR_OPCODE = 7'b0000011; localparam [2:0] LW_INSTR_FUNCT3 = 3'b010;
            localparam [6:0] LBU_INSTR_OPCODE = 7'b0000011; localparam [2:0] LBU_INSTR_FUNCT3 = 3'b100;
            localparam [6:0] LHU_INSTR_OPCODE = 7'b0000011; localparam [2:0] LHU_INSTR_FUNCT3 = 3'b101;
            localparam [6:0] SB_INSTR_OPCODE = 7'b0100011; localparam [2:0] SB_INSTR_FUNCT3 = 3'b000;
            localparam [6:0] SH_INSTR_OPCODE = 7'b0100011; localparam [2:0] SH_INSTR_FUNCT3 = 3'b001;
            localparam [6:0] SW_INSTR_OPCODE = 7'b0100011; localparam [2:0] SW_INSTR_FUNCT3 = 3'b010;
            localparam [6:0] ADDI_INSTR_OPCODE = 7'b0010011; localparam [2:0] ADDI_INSTR_FUNCT3 = 3'b000;
            localparam [6:0] SLTI_INSTR_OPCODE = 7'b0010011; localparam [2:0] SLTI_INSTR_FUNCT3 = 3'b010;
            localparam [6:0] SLTIU_INSTR_OPCODE = 7'b0010011; localparam [2:0] SLTIU_INSTR_FUNCT3 = 3'b011;
            localparam [6:0] XORI_INSTR_OPCODE = 7'b0010011; localparam [2:0] XORI_INSTR_FUNCT3 = 3'b100;
            localparam [6:0] ORI_INSTR_OPCODE = 7'b0010011; localparam [2:0] ORI_INSTR_FUNCT3 = 3'b110;
            localparam [6:0] ANDI_INSTR_OPCODE = 7'b0010011; localparam [2:0] ANDI_INSTR_FUNCT3 = 3'b111;
            localparam [6:0] SLLI_INSTR_OPCODE = 7'b0010011; localparam [2:0] SLLI_INSTR_FUNCT3 = 3'b001;
            localparam [6:0] SRLI_SRAI_INSTR_OPCODE = 7'b0010011; localparam [2:0] SRLI_SRAI_INSTR_FUNCT3 = 3'b101;  // Two instructions distinguished by an immediate bit, treated as a single instruction.
            localparam [6:0] ADD_SUB_INSTR_OPCODE = 7'b0110011; localparam [2:0] ADD_SUB_INSTR_FUNCT3 = 3'b000;  // Treated as a single instruction.
            localparam [6:0] SLL_INSTR_OPCODE = 7'b0110011; localparam [2:0] SLL_INSTR_FUNCT3 = 3'b001;
            localparam [6:0] SLT_INSTR_OPCODE = 7'b0110011; localparam [2:0] SLT_INSTR_FUNCT3 = 3'b010;
            localparam [6:0] SLTU_INSTR_OPCODE = 7'b0110011; localparam [2:0] SLTU_INSTR_FUNCT3 = 3'b011;
            localparam [6:0] XOR_INSTR_OPCODE = 7'b0110011; localparam [2:0] XOR_INSTR_FUNCT3 = 3'b100;
            localparam [6:0] SRL_SRA_INSTR_OPCODE = 7'b0110011; localparam [2:0] SRL_SRA_INSTR_FUNCT3 = 3'b101;  // Treated as a single instruction.
            localparam [6:0] OR_INSTR_OPCODE = 7'b0110011; localparam [2:0] OR_INSTR_FUNCT3 = 3'b110;
            localparam [6:0] AND_INSTR_OPCODE = 7'b0110011; localparam [2:0] AND_INSTR_FUNCT3 = 3'b111;
            //m4_instr(_, 32, I, 00011, 000, FENCE)
            //m4_instr(_, 32, I, 00011, 001, FENCE_I)
            //m4_instr(_, 32, I, 11100, 000, ECALL_EBREAK)  // Two instructions distinguished by an immediate bit, treated as a single instruction.
            //m4_instr(_, 32, I, 11100, 001, CSRRW)
            //m4_instr(_, 32, I, 11100, 010, CSRRS)
            //m4_instr(_, 32, I, 11100, 011, CSRRC)
            //m4_instr(_, 32, I, 11100, 101, CSRRWI)
            //m4_instr(_, 32, I, 11100, 110, CSRRSI)
            //m4_instr(_, 32, I, 11100, 111, CSRRCI)
            
            
            
            
              // Two instructions distinguished by an immediate bit, treated as a single instruction.
            
            
              // Two instructions distinguished by an immediate bit, treated as a single instruction.
              // Two instructions distinguished by an immediate bit, treated as a single instruction.
            
              // Two instructions distinguished by an immediate bit, treated as a single instruction.
            
            
            
            
            
            
            
            
            
            
            
            
            
            // RV32A and RV64A
            // NOT IMPLEMENTED. These are distinct in the func7 field.
            // RV32F and RV64F
            // NOT IMPLEMENTED.
            // RV32D and RV64D
            // NOT IMPLEMENTED.
      
      
         // ^---------------------
      \end_source
   
      // The program in an instruction memory.
      \SV_plus
         logic [31:0] instrs [0:11-1];
      \source warp-v.tlv 829   // Instantiated from warp-v.tlv, 1299 as: m4+indirect(M4_isa['_cnt10_prog'])
         
      \end_source
   
   
      // /=========\
      // | The CPU |
      // \=========/
      
      $reset = *reset;
   
      |fetch
         /instr
            @0
               $reset = /top<>0$reset;
            
               $fetch = 1'b1;  // always fetch
               ?$fetch
   
                  // =====
                  // Fetch
                  // =====
   
                  $raw[31:0] = *instrs\[$Pc[5:2]\];
               
            @0
               // A returning load clobbers the instruction.
               // (Could do this with lower latency. Right now it goes through memory pipeline $ANY, and
               //  it is non-speculative. Both could easily be fixed.)
               $returning_ld = /top|mem/data>>1$valid_ld;
               
               // =======
               // Next PC
               // =======
               
               $Pc[31:2] <=
                  $reset ? 30'b0 :
                  >>1$valid_pred_taken_branch ? >>1$branch_target :
                  >>1$valid_mispred_branch ? >>1$branch_target :
                  >>1$valid_jump ? >>1$jump_target :
                  >>2$good_path_trap ? 0 :  // TODO: trap target?
                  >>1$replay ? >>1$Pc :
                  $returning_ld ? $RETAIN :  // Returning load, so next PC is the previous next PC (unless there was a branch that wasn't visible yet)
                           $Pc + 30'b1;
               
            @0
   
               // ======
               // DECODE
               // ======
   
               // Decode of the fetched instruction
               $valid_decode = $fetch;  // Always decode if we fetch.
               \source warp-v.tlv 1014   // Instantiated from warp-v.tlv, 1350 as: m4+indirect(M4_isa['_decode'])
                  ?$valid_decode
               
                     // =================================
               
                     // Extract fields of $raw (instruction) into $raw_<field>[x:0].
                     {$raw_funct7[6:0], $raw_rs2[4:0], $raw_rs1[4:0], $raw_funct3[2:0], $raw_rd[4:0], $raw_op5[4:0], $raw_op2[1:0]} = $raw;
                     `BOGUS_USE($raw_funct7 $raw_op2)  // Delete once its used.
                     // Extract immediate fields into type-specific signals.
                     // (User ISA Manual 2.2, Fig. 2.4)
                     $raw_i_imm[31:0] = {{21{$raw[31]}}, $raw[30:20]};
                     $raw_s_imm[31:0] = {{21{$raw[31]}}, $raw[30:25], $raw[11:7]};
                     $raw_b_imm[31:0] = {{20{$raw[31]}}, $raw[7], $raw[30:25], $raw[11:8], 1'b0};
                     $raw_u_imm[31:0] = {$raw[31:12], {12{1'b0}}};
                     //$raw_j_imm[31:0] = {{12{$raw[31]}}, $raw[19:12], $raw[20], $raw[30:21], 1'b0};
                     // Extract other type/instruction-specific fields.
                     $raw_shamt[6:0] = $raw[26:20];
                     $raw_aq = $raw[26];
                     $raw_rl = $raw[25];
                     $raw_rs3[4:0] = $raw[31:27];
                     $raw_rm[2:0] = $raw_funct3;
                     `BOGUS_USE($raw_shamt $raw_aq $raw_rl $raw_rs3 $raw_rm)  // Avoid "unused" messages. Remove these as they become used.
               
                     // Instruction type decode
                     \SV_plus
                        assign $$is_i_type = INSTR_TYPE_I_MASK[$raw_op5]; assign $$is_r_type = INSTR_TYPE_R_MASK[$raw_op5]; assign $$is_ri_type = INSTR_TYPE_RI_MASK[$raw_op5]; assign $$is_r4_type = INSTR_TYPE_R4_MASK[$raw_op5]; assign $$is_s_type = INSTR_TYPE_S_MASK[$raw_op5]; assign $$is_b_type = INSTR_TYPE_B_MASK[$raw_op5]; assign $$is_j_type = INSTR_TYPE_J_MASK[$raw_op5]; assign $$is_u_type = INSTR_TYPE_U_MASK[$raw_op5]; assign $$is___type = INSTR_TYPE___MASK[$raw_op5]; 
               
                     // Instruction decode.
                     \source warp-v.tlv 1006   // Instantiated from warp-v.tlv, 1042 as: m4+riscv_decode_expr()
                        $is_lui_instr = $raw_op5 == 5'b01101;
                        $is_auipc_instr = $raw_op5 == 5'b00101;
                        $is_jal_instr = $raw_op5 == 5'b11011;
                        $is_jalr_instr = $raw_op5 == 5'b11001 && $raw_funct3 == 3'b000;
                        $is_beq_instr = $raw_op5 == 5'b11000 && $raw_funct3 == 3'b000;
                        $is_bne_instr = $raw_op5 == 5'b11000 && $raw_funct3 == 3'b001;
                        $is_blt_instr = $raw_op5 == 5'b11000 && $raw_funct3 == 3'b100;
                        $is_bge_instr = $raw_op5 == 5'b11000 && $raw_funct3 == 3'b101;
                        $is_bltu_instr = $raw_op5 == 5'b11000 && $raw_funct3 == 3'b110;
                        $is_bgeu_instr = $raw_op5 == 5'b11000 && $raw_funct3 == 3'b111;
                        $is_lb_instr = $raw_op5 == 5'b00000 && $raw_funct3 == 3'b000;
                        $is_lh_instr = $raw_op5 == 5'b00000 && $raw_funct3 == 3'b001;
                        $is_lw_instr = $raw_op5 == 5'b00000 && $raw_funct3 == 3'b010;
                        $is_lbu_instr = $raw_op5 == 5'b00000 && $raw_funct3 == 3'b100;
                        $is_lhu_instr = $raw_op5 == 5'b00000 && $raw_funct3 == 3'b101;
                        $is_sb_instr = $raw_op5 == 5'b01000 && $raw_funct3 == 3'b000;
                        $is_sh_instr = $raw_op5 == 5'b01000 && $raw_funct3 == 3'b001;
                        $is_sw_instr = $raw_op5 == 5'b01000 && $raw_funct3 == 3'b010;
                        $is_addi_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b000;
                        $is_slti_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b010;
                        $is_sltiu_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b011;
                        $is_xori_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b100;
                        $is_ori_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b110;
                        $is_andi_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b111;
                        $is_slli_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b001;
                        $is_srli_srai_instr = $raw_op5 == 5'b00100 && $raw_funct3 == 3'b101;
                        $is_add_sub_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b000;
                        $is_sll_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b001;
                        $is_slt_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b010;
                        $is_sltu_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b011;
                        $is_xor_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b100;
                        $is_srl_sra_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b101;
                        $is_or_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b110;
                        $is_and_instr = $raw_op5 == 5'b01100 && $raw_funct3 == 3'b111;
                        
                     \end_source
               
                     $illegal = 1'b1 && ! $is_lui_instr && ! $is_auipc_instr && ! $is_jal_instr && ! $is_jalr_instr && ! $is_beq_instr && ! $is_bne_instr && ! $is_blt_instr && ! $is_bge_instr && ! $is_bltu_instr && ! $is_bgeu_instr && ! $is_lb_instr && ! $is_lh_instr && ! $is_lw_instr && ! $is_lbu_instr && ! $is_lhu_instr && ! $is_sb_instr && ! $is_sh_instr && ! $is_sw_instr && ! $is_addi_instr && ! $is_slti_instr && ! $is_sltiu_instr && ! $is_xori_instr && ! $is_ori_instr && ! $is_andi_instr && ! $is_slli_instr && ! $is_srli_srai_instr && ! $is_add_sub_instr && ! $is_sll_instr && ! $is_slt_instr && ! $is_sltu_instr && ! $is_xor_instr && ! $is_srl_sra_instr && ! $is_or_instr && ! $is_and_instr;
                     $jump = $is_jalr_instr;  // "Jump" in this code means absolute. "Jump" in RISC-V means unconditional.
                     $conditional_branch = $is_b_type;
                     $branch = $is_b_type || $is_j_type;
                     $ld = $raw[6:3] == 4'b0;
                     $st = $is_s_type;
                     `BOGUS_USE($is___type $is_u_type)
               
                     // Output signals.
                     /src[2:1]
                        // Reg valid for this source, based on instruction type.
                        $is_reg = /instr$is_r_type || /instr$is_r4_type || (/instr$is_i_type && (#src == 1)) || /instr$is_ri_type || /instr$is_s_type || /instr$is_b_type;
                        $reg[4:0] = (#src == 1) ? /instr$raw_rs1 : /instr$raw_rs2;
                          
                     // For debug.
                     $mnemonic[10*8-1:0] = $is_lui_instr ? "LUI       " : $is_auipc_instr ? "AUIPC     " : $is_jal_instr ? "JAL       " : $is_jalr_instr ? "JALR      " : $is_beq_instr ? "BEQ       " : $is_bne_instr ? "BNE       " : $is_blt_instr ? "BLT       " : $is_bge_instr ? "BGE       " : $is_bltu_instr ? "BLTU      " : $is_bgeu_instr ? "BGEU      " : $is_lb_instr ? "LB        " : $is_lh_instr ? "LH        " : $is_lw_instr ? "LW        " : $is_lbu_instr ? "LBU       " : $is_lhu_instr ? "LHU       " : $is_sb_instr ? "SB        " : $is_sh_instr ? "SH        " : $is_sw_instr ? "SW        " : $is_addi_instr ? "ADDI      " : $is_slti_instr ? "SLTI      " : $is_sltiu_instr ? "SLTIU     " : $is_xori_instr ? "XORI      " : $is_ori_instr ? "ORI       " : $is_andi_instr ? "ANDI      " : $is_slli_instr ? "SLLI      " : $is_srli_srai_instr ? "SRLI_SRAI " : $is_add_sub_instr ? "ADD_SUB   " : $is_sll_instr ? "SLL       " : $is_slt_instr ? "SLT       " : $is_sltu_instr ? "SLTU      " : $is_xor_instr ? "XOR       " : $is_srl_sra_instr ? "SRL_SRA   " : $is_or_instr ? "OR        " : $is_and_instr ? "AND       " :  "ILLEGAL   ";
                     `BOGUS_USE($mnemonic)
                  // Condition signals must not themselves be conditioned (currently).
                  $valid_decode_branch = $valid_decode && $branch;
                  $dest_reg[4:0] = $returning_ld ? $returning_ld_dest_reg : $raw_rd;
                  $dest_reg_valid = (($valid_decode && ! $is_s_type && ! $is_b_type) || $returning_ld) &&
                                    | $dest_reg;   // r0 not valid.
                  // Actually load.
                  $spec_ld = $valid_decode && $ld;
                  
               \end_source
               
               // Returning load doesn't decode the instruction. Provide value to force for dest reg. 
               $returning_ld_dest_reg[4:0] = /top|mem/data>>1$dest_reg;
            
            \source warp-v.tlv 1265   // Instantiated from warp-v.tlv, 1355 as: m4+indirect(['branch_pred_']M4_BRANCH_PRED)
               @0
                  $pred_taken = 1'b0;
            \end_source
            
            @0
               // ======
               // Reg Rd
               // ======
               
               /regs[31:1]
               /src[2:1]
                  $is_reg_condition = $is_reg && /instr$valid_decode;
                  ?$is_reg_condition
                     $reg_value[31:0] =
                        
                        // Bypass stages:
                        
                        
                        
                        /instr/regs[$reg]>>0$Value;
                  $replay = $is_reg_condition && /instr/regs[$reg]>>1$next_pending;
               $replay = | /src[*]$replay || ($dest_reg_valid && /regs[$dest_reg]>>1$next_pending);
            
            
            // =======
            // Execute
            // =======
            \source warp-v.tlv 1069   // Instantiated from warp-v.tlv, 1380 as: m4+indirect(M4_isa['_exe'], @M4_EXECUTE_STAGE, @M4_RESULT_STAGE)
               @0
                  ?$valid_decode_branch
                     $branch_target[31:2] = $Pc + $raw_b_imm[31:2];
                     // TODO: Deal with misaligned address.
               @0
                  // Execution.
                  $valid_exe = $valid_decode; // Execute if we decoded.
                  
                  // Compute results for each instruction, independent of decode (power-hungry, but fast).
                  ?$valid_exe
                     $equal = /src[1]$reg_value == /src[2]$reg_value;
                  ?$valid_branch
                     $taken =
                        $is_j_type ||
                        ($is_beq_instr && $equal) ||
                        ($is_bne_instr && ! $equal) ||
                        (($is_blt_instr || $is_bltu_instr || $is_bge_instr || $is_bgeu_instr) &&
                         (($is_bge_instr || $is_bgeu_instr) ^
                          ({($is_blt_instr ^ /src[1]$reg_value[31]), /src[1]$reg_value[31-1:0]} <
                           {($is_blt_instr ^ /src[2]$reg_value[31]), /src[2]$reg_value[31-1:0]}
                          )
                         )
                        );
                  ?$valid_jump
                     $jump_target[31:2] = /src[1]$reg_value[31:2] + $raw_i_imm[31:2];
                     // TODO: This assumes aligned addresses. Must deal with zeroing of byte bit and misaligned address.
                  ?$valid_exe
                     // Compute each individual instruction result, combined per-instruction by a macro.
                     
                     $lui_rslt[31:0] = $raw_u_imm;
                     $auipc_rslt[31:0] = {$Pc, 2'b0} + $raw_u_imm;
                     $jal_rslt[31:0] = {$Pc, 2'b0} + 4;
                     $jalr_rslt[31:0] = {$Pc, 2'b0} + 4;
                     $lb_rslt[31:0] = 32'b0;
                     $lh_rslt[31:0] = 32'b0;
                     $lw_rslt[31:0] = $returning_ld_data;
                     $lbu_rslt[31:0] = 32'b0;
                     $lhu_rslt[31:0] = 32'b0;
                     $addi_rslt[31:0] = /src[1]$reg_value + $raw_i_imm;  // Note: this has its own adder; could share w/ add/sub.
                     $slti_rslt[31:0] = (/src[1]$reg_value < $raw_i_imm) ? 1 : 0 ;
                     $sltiu_rslt[31:0] = 32'b0;
                     $xori_rslt[31:0] = /src[1]$reg_value ^ $raw_i_imm;
                     $ori_rslt[31:0] = /src[1]$reg_value | $raw_i_imm;
                     $andi_rslt[31:0] = /src[1]$reg_value & $raw_i_imm;
                     $slli_rslt[31:0] = /src[1]$reg_value << /src[2]$reg_value[4:0];
                     $srli_srai_rslt[31:0] = 32'b0;
                     $add_sub_rslt[31:0] =  /src[1]$reg_value + /src[2]$reg_value;
                     $sll_rslt[31:0] = /src[1]$reg_value << /src[2]$reg_value[4:0];
                     $slt_rslt[31:0] = (/src[1]$reg_value < /src[2]$reg_value) ? 1 : 0;
                     $sltu_rslt[31:0] = 32'b0;
                     $xor_rslt[31:0] = /src[1]$reg_value ^ /src[2]$reg_value;
                     $srl_sra_rslt[31:0] = 32'b0;
                     $or_rslt[31:0] = /src[1]$reg_value | /src[2]$reg_value;
                     $and_rslt[31:0] = /src[1]$reg_value & /src[2]$reg_value;
               @0
                  ?$valid_ld_st
                     $addr[31:0] = /src[1]$reg_value + ($ld ? $raw_i_imm : $raw_s_imm);
                  ?$valid_st
                     $st_value[31:0] = /src[2]$reg_value;
            
               @0
                  // Mux the correct result.
                  \source warp-v.tlv 1009   // Instantiated from warp-v.tlv, 1132 as: m4+riscv_rslt_mux_expr()
                     $rslt[31:0] = 
                         $returning_ld ? $returning_ld_data :
                         32'b0 |
                         ({32{$is_lui_instr}} & $lui_rslt) |
                         ({32{$is_auipc_instr}} & $auipc_rslt) |
                         ({32{$is_jal_instr}} & $jal_rslt) |
                         ({32{$is_jalr_instr}} & $jalr_rslt) |
                         ({32{$is_lb_instr}} & $lb_rslt) |
                         ({32{$is_lh_instr}} & $lh_rslt) |
                         ({32{$is_lw_instr}} & $lw_rslt) |
                         ({32{$is_lbu_instr}} & $lbu_rslt) |
                         ({32{$is_lhu_instr}} & $lhu_rslt) |
                         ({32{$is_addi_instr}} & $addi_rslt) |
                         ({32{$is_slti_instr}} & $slti_rslt) |
                         ({32{$is_sltiu_instr}} & $sltiu_rslt) |
                         ({32{$is_xori_instr}} & $xori_rslt) |
                         ({32{$is_ori_instr}} & $ori_rslt) |
                         ({32{$is_andi_instr}} & $andi_rslt) |
                         ({32{$is_slli_instr}} & $slli_rslt) |
                         ({32{$is_srli_srai_instr}} & $srli_srai_rslt) |
                         ({32{$is_add_sub_instr}} & $add_sub_rslt) |
                         ({32{$is_sll_instr}} & $sll_rslt) |
                         ({32{$is_slt_instr}} & $slt_rslt) |
                         ({32{$is_sltu_instr}} & $sltu_rslt) |
                         ({32{$is_xor_instr}} & $xor_rslt) |
                         ({32{$is_srl_sra_instr}} & $srl_sra_rslt) |
                         ({32{$is_or_instr}} & $or_rslt) |
                         ({32{$is_and_instr}} & $and_rslt);
                  \end_source
               
            \end_source
                  
            @0
   
               // ============
               // Control Flow
               // ============
               
               // Terminology:
               // Instruction: An instruction, as viewed by the CPU pipeline (i.e. ld and ld_return are separate instructions).
               // ISA Instruction: An instruction, as defined by the ISA.
               // Squash: Do not commit the results of this instruction.
               // Good Path: On the proper flow of execution of the program.
               // Redirect: Adjust the PC from the predicted next-PC.
               // Redirect Shadow: Between the instruction causing the redirect and the redirect target instruction.
               // Commit: Results are made visible to subsequent instructions.
               // Retire: Commit and completes an ISA instruction.
               
               // Instruction control flow characterization:
               //
               // Traps include:
               //   o illegal instructions
               //   o misaligned PC
               //   o ...
               $trap = $illegal;  // TODO: || $misaligned_pc...
               $mispred_branch = $branch && ! ($conditional_branch && ! $taken);
               $redirecting_squash = $replay || $trap;  // Instruction would squash and redirect the PC (if good-path).
               $in_redirect_shadow = | $RedirectShadowCnt;  // Instruction is in the shadow of a redirect (not the cause of it).
   
               // Good path & squash.
               $good_path = $valid_exe && ! $in_redirect_shadow;  // This instruction is on the good path (though it may be replayed).
               $squash = ! $good_path || $redirecting_squash;  // Instruction will not commit results.
               $commit = ! $squash;
   
               // Trap conditions conditioned upon good-path.
               $good_path_illegal = $illegal && $good_path;
               $good_path_trap = $trap && $good_path;
               `BOGUS_USE($good_path_illegal)
               // Signals conditioned upon commit.
               $valid_jump = $jump && $commit;
               $valid_branch = $branch && $commit;
               $valid_pred_taken_branch = $valid_branch && $pred_taken;
               $valid_mispred_branch = $mispred_branch && $commit;
               $valid_dest_reg_valid = $dest_reg_valid && $commit;
               $valid_ld = $ld && $commit;
               $valid_st = $st && $commit;
               $valid_ld_st = $valid_ld || $valid_st;
   
               // Squash. Keep a count of the number of cycles remaining in the shadow of a mispredict.
               $RedirectShadowCnt[2:0] <=
                  $reset                ? 3'b0 :
                  $valid_pred_taken_branch ? 1 :
                  $valid_mispred_branch ? 1 :
                  $valid_jump           ? 1 :
                  $good_path_trap       ? 2 :
                  $replay               ? 2 - 3'b1 :
                  $RedirectShadowCnt == 3'b0    ? 3'b0 :
                                          $RedirectShadowCnt - 3'b1;
                                          
               $returning_ld_data[31:0] = /top|mem/data>>1$ld_rslt;
      \source warp-v.tlv 1210   // Instantiated from warp-v.tlv, 1440 as: m4+fixed_latency_fake_memory(/top, 0)
         |fetch
            /instr
               // ====
               // Load
               // ====
               
               /mem[31:0]
               ?$spec_ld
                  @0
                     $ld_rslt[31:0] = /mem[$addr[4:0]]$Word;
               
               // Array writes are not currently permitted to use assignment
               // syntax, so \always_comb is used, and this must be outside of
               // when conditions, so we need to use if. <<1 because no <= support
               // in this context. (This limitation will be lifted.)
      
               @0
                  // =====
                  // Store
                  // =====
      
                  \SV_plus
                     always @ (posedge clk) begin
                        if ($valid_st)
                           /mem[$addr[4:0]]<<1$$Word[31:0] = $st_value;
                     end
      
         // Return loads in |mem pipeline. We just hook up the |mem pipeline to the |fetch pipeline w/ the
         // right alignment.
         |mem
            /data
               @0
                  $ANY = /top|fetch/instr>>0$ANY;
      \end_source
      |fetch
         /instr
            @0
               // =========
               // Reg Write
               // =========
   
               $reg_write = $reset ? 1'b0 : $valid_dest_reg_valid;
               \SV_plus
                  always @ (posedge clk) begin
                     if ($reg_write)
                        /regs[$dest_reg]<<1$$Value[31:0] = $rslt;
                  end
               
               // =======================
               // For Formal Verification
               // =======================
               // Currenty we fetch an instruction every cycle, and squash is the only
               //   mechanism to avoid retiring. Also loads issue in two parts, the $ld and the
               //   $returning_ld.
               $retire = $commit && ! $ld;
               `BOGUS_USE($retire $good_path_trap)
            
            // There's no bypass on pending, so we must write the same cycle we read.
            @0
               /regs[*]
                  $reg_match = /instr$dest_reg == #regs;
                  $next_pending =  // Should be state, but need to consume prior to flop, which SandPiper doesn't support, yet.
                     /instr$reset ? 1'b0 :
                     // set for loads
                     /instr$valid_ld && $reg_match   ? 1'b1 :
                     // clear when load returns
                     /instr$returning_ld && $reg_match ? 1'b0 :
                                  $RETAIN;
      
   \end_source

   
   // Assert these to end simulation (before Makerchip cycle limit).
!  *passed = ! *reset;
!  *failed = ! *reset;
\SV
   endmodule
