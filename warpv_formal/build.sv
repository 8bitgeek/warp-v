`line 2 "repos/warp-v/warp-v.tlv" 0 //_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
`include "sp_verilog.vh" //_\SV
   // -----------------------------------------------------------------------------
   // Copyright (c) 2017, Steven F. Hoover
   // 
   // Redistribution and use in source and binary forms, with or without
   // modification, are permitted provided that the following conditions are met:
   // 
   //     * Redistributions of source code must retain the above copyright notice,
   //       this list of conditions and the following disclaimer.
   //     * Redistributions in binary form must reproduce the above copyright
   //       notice, this list of conditions and the following disclaimer in the
   //       documentation and/or other materials provided with the distribution.
   //     * The name Steven F. Hoover
   //       may not be used to endorse or promote products derived from this software
   //       without specific prior written permission.
   // 
   // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
   // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   // -----------------------------------------------------------------------------

   // This code is mastered in https://github.com/stevehoover/warp-v.git

//_\SV
   module warpv(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed,



output  rvfi_valid,      
output [63 : 0] rvfi_order,      
output [31: 0] rvfi_insn,       
output  rvfi_trap,       
output  rvfi_halt,       
output  rvfi_intr,       
output [4: 0] rvfi_rs1_addr,   
output [4: 0] rvfi_rs2_addr,   
output [31: 0] rvfi_rs1_rdata,  
output [31: 0] rvfi_rs2_rdata,  
output [4: 0] rvfi_rd_addr,    
output [31: 0] rvfi_rd_wdata,   
output [31:0] rvfi_pc_rdata,   
output [31:0] rvfi_pc_wdata ,   
output [31:0] rvfi_mem_addr,   
output [3: 0] rvfi_mem_rmask,  
output [3: 0] rvfi_mem_wmask,  
output [31: 0] rvfi_mem_rdata,  
output [31: 0] rvfi_mem_wdata


      ); 
`line 586 "repos/warp-v/warp-v.tlv" 1
//_\SV
/* verilator lint_on WIDTH */  // Let's be strict about bit widths.






`line 1447 "repos/warp-v/warp-v.tlv" 1
`include "build_gen.sv" //_\TLV
   // =================
   //
   //    THE MODEL
   //
   // =================

 (* keep *)   reg [63:0] rvfi_order_reg;
 (* keep *)   reg [31:0] rvfi_rd_wdata_reg;
 (* keep *)   reg [31:0] rvfi_rd_wdata_dly_reg;
 (* keep *)   reg [31:0] rvfi_pc_wdata_reg;

always @(posedge clk)
begin
   rvfi_order_reg      <= reset ? 0 : rvfi_order_reg + rvfi_valid;
   rvfi_rd_wdata_dly_reg   <= FETCH_Instr_rslt_a0;
   rvfi_rd_wdata_reg   <= FETCH_Instr_reg_write_a0 ? rvfi_rd_wdata_dly_reg : rvfi_rd_wdata_reg;
   rvfi_pc_wdata_reg   <= FETCH_Instr_Pc_n1[31:2];
end


assign rvfi_valid       = FETCH_Instr_retire_a0 && !FETCH_Instr_returning_ld_a0; //
assign rvfi_insn        = FETCH_Instr_raw_a0;
assign rvfi_halt        = FETCH_Instr_illegal_a0;
assign rvfi_trap        = FETCH_Instr_trap_a0;
assign rvfi_order       = rvfi_order_reg;
assign rvfi_intr        = 1'b0;
assign rvfi_rs1_addr    = FETCH_Instr_is_u_type_a0 ? 0 : FETCH_Instr_raw_rs1_a0;
assign rvfi_rs2_addr    = (FETCH_Instr_is_i_type_a0 | FETCH_Instr_is_u_type_a0) ? 0 : FETCH_Instr_raw_rs2_a0;
assign rvfi_rs1_rdata   = L1b_FETCH_Instr_Src[1].L1_reg_value_a0;
assign rvfi_rs2_rdata   = L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
assign rvfi_rd_addr     = FETCH_Instr_is_s_type_a0 ? 0 : FETCH_Instr_raw_rd_a0;
assign rvfi_rd_wdata    = rvfi_rd_addr ? FETCH_Instr_rslt_a0 : 0;
assign rvfi_pc_rdata    = FETCH_Instr_Pc_a0[31:2];
assign rvfi_pc_wdata    = rvfi_pc_wdata_reg +  4'd4;
assign rvfi_mem_addr    = FETCH_Instr_addr_a0;
assign rvfi_mem_rmask   = (FETCH_Instr_ld_a0 ) ? 4'b1111 : 4'b0000;
assign rvfi_mem_wmask   = FETCH_Instr_valid_st_a0 ? 4'b1111 : 4'b0000;
assign rvfi_mem_rdata   = FETCH_Instr_ld_rslt_a0;
assign rvfi_mem_wdata   = FETCH_Instr_st_value_a0;
   
   `line 1259 "repos/warp-v/warp-v.tlv" 1   // Instantiated from repos/warp-v/warp-v.tlv, 1454 as: m4+cpu()
      
      // Generated logic
      `line 835 "repos/warp-v/warp-v.tlv" 1   // Instantiated from repos/warp-v/warp-v.tlv, 1261 as: m4+indirect(M4_isa['_gen'])
         
         // v---------------------
         // Instruction characterization
      
         // M4 ugliness for instruction characterization.
         
         // For each opcode[6:2]
         // (User ISA Manual 2.2, Table 19.1)
         // Associate opcode[6:2] ([1:0] are 2'b11) with mnemonic and instruction type.
         // Instruction type is not in the table, but there seems to be a single instruction type for each of these,
         // so that is mapped here as well.
         // op5(bits, type, mnemonic)
         /*SV_plus*/
            localparam [4:0] OP5_LOAD = 5'b00000;
            localparam [4:0] OP5_LOAD_FP = 5'b00001;
            localparam [4:0] OP5_CUSTOM_0 = 5'b00010;
            localparam [4:0] OP5_MISC_MEM = 5'b00011;
            localparam [4:0] OP5_OP_IMM = 5'b00100;
            localparam [4:0] OP5_AUIPC = 5'b00101;
            localparam [4:0] OP5_OP_IMM_32 = 5'b00110;
            localparam [4:0] OP5_48B1 = 5'b00111;
            localparam [4:0] OP5_STORE = 5'b01000;
            localparam [4:0] OP5_STORE_FP = 5'b01001;
            localparam [4:0] OP5_CUSTOM_1 = 5'b01010;
            localparam [4:0] OP5_AMO = 5'b01011;  // (R-type, but rs2 = const for some, based on funct7 which doesn't exist for I-type?? R-type w/ ignored R2?)
            localparam [4:0] OP5_OP = 5'b01100;
            localparam [4:0] OP5_LUI = 5'b01101;
            localparam [4:0] OP5_OP_32 = 5'b01110;
            localparam [4:0] OP5_64B = 5'b01111;
            localparam [4:0] OP5_MADD = 5'b10000;
            localparam [4:0] OP5_MSUB = 5'b10001;
            localparam [4:0] OP5_NMSUB = 5'b10010;
            localparam [4:0] OP5_NMADD = 5'b10011;
            localparam [4:0] OP5_OP_FP = 5'b10100;  // (R-type, but rs2 = const for some, based on funct7 which doesn't exist for I-type?? R-type w/ ignored R2?)
            localparam [4:0] OP5_RESERVED_1 = 5'b10101;
            localparam [4:0] OP5_CUSTOM_2_RV128 = 5'b10110;
            localparam [4:0] OP5_48B2 = 5'b10111;
            localparam [4:0] OP5_BRANCH = 5'b11000;
            localparam [4:0] OP5_JALR = 5'b11001;
            localparam [4:0] OP5_RESERVED_2 = 5'b11010;
            localparam [4:0] OP5_JAL = 5'b11011;
            localparam [4:0] OP5_SYSTEM = 5'b11100;
            localparam [4:0] OP5_RESERVED_3 = 5'b11101;
            localparam [4:0] OP5_CUSTOM_3_RV128 = 5'b11110;
            localparam [4:0] OP5_80B = 5'b11111;
            
         /*SV_plus*/
            // Not sure these are ever used.
            localparam INSTR_TYPE_I_MASK = 0 | (1 << 5'b00000) | (1 << 5'b00001) | (1 << 5'b00100) | (1 << 5'b00110) | (1 << 5'b11001); localparam INSTR_TYPE_R_MASK = 0 | (1 << 5'b01100) | (1 << 5'b01110); localparam INSTR_TYPE_RI_MASK = 0 | (1 << 5'b01011) | (1 << 5'b10100); localparam INSTR_TYPE_R4_MASK = 0 | (1 << 5'b10000) | (1 << 5'b10001) | (1 << 5'b10010) | (1 << 5'b10011); localparam INSTR_TYPE_S_MASK = 0 | (1 << 5'b01000) | (1 << 5'b01001); localparam INSTR_TYPE_B_MASK = 0 | (1 << 5'b11000); localparam INSTR_TYPE_J_MASK = 0 | (1 << 5'b11011); localparam INSTR_TYPE_U_MASK = 0 | (1 << 5'b00101) | (1 << 5'b01101); localparam INSTR_TYPE___MASK = 0 | (1 << 5'b00010) | (1 << 5'b00011) | (1 << 5'b00111) | (1 << 5'b01010) | (1 << 5'b01111) | (1 << 5'b10101) | (1 << 5'b10110) | (1 << 5'b10111) | (1 << 5'b11010) | (1 << 5'b11100) | (1 << 5'b11101) | (1 << 5'b11110) | (1 << 5'b11111); 
            
         /*SV_plus*/
            // Instruction characterization.
            // (User ISA Manual 2.2, Table 19.2)
            // instr(type,  // (this is simply verified vs. op5)
            //       |  bit-width,
            //       |  |   extension, 
            //       |  |   |  opcode[6:2],  // (aka op5)
            //       |  |   |  |      func3,   // (if applicable)
            //       |  |   |  |      |    mnemonic)
            localparam [6:0] LUI_INSTR_OPCODE = 7'b0110111;
            localparam [6:0] AUIPC_INSTR_OPCODE = 7'b0010111;
            localparam [6:0] JAL_INSTR_OPCODE = 7'b1101111;
            localparam [6:0] JALR_INSTR_OPCODE = 7'b1100111; localparam [2:0] JALR_INSTR_FUNCT3 = 3'b000;
            localparam [6:0] BEQ_INSTR_OPCODE = 7'b1100011; localparam [2:0] BEQ_INSTR_FUNCT3 = 3'b000;
            localparam [6:0] BNE_INSTR_OPCODE = 7'b1100011; localparam [2:0] BNE_INSTR_FUNCT3 = 3'b001;
            localparam [6:0] BLT_INSTR_OPCODE = 7'b1100011; localparam [2:0] BLT_INSTR_FUNCT3 = 3'b100;
            localparam [6:0] BGE_INSTR_OPCODE = 7'b1100011; localparam [2:0] BGE_INSTR_FUNCT3 = 3'b101;
            localparam [6:0] BLTU_INSTR_OPCODE = 7'b1100011; localparam [2:0] BLTU_INSTR_FUNCT3 = 3'b110;
            localparam [6:0] BGEU_INSTR_OPCODE = 7'b1100011; localparam [2:0] BGEU_INSTR_FUNCT3 = 3'b111;
            localparam [6:0] LB_INSTR_OPCODE = 7'b0000011; localparam [2:0] LB_INSTR_FUNCT3 = 3'b000;
            localparam [6:0] LH_INSTR_OPCODE = 7'b0000011; localparam [2:0] LH_INSTR_FUNCT3 = 3'b001;
            localparam [6:0] LW_INSTR_OPCODE = 7'b0000011; localparam [2:0] LW_INSTR_FUNCT3 = 3'b010;
            localparam [6:0] LBU_INSTR_OPCODE = 7'b0000011; localparam [2:0] LBU_INSTR_FUNCT3 = 3'b100;
            localparam [6:0] LHU_INSTR_OPCODE = 7'b0000011; localparam [2:0] LHU_INSTR_FUNCT3 = 3'b101;
            localparam [6:0] SB_INSTR_OPCODE = 7'b0100011; localparam [2:0] SB_INSTR_FUNCT3 = 3'b000;
            localparam [6:0] SH_INSTR_OPCODE = 7'b0100011; localparam [2:0] SH_INSTR_FUNCT3 = 3'b001;
            localparam [6:0] SW_INSTR_OPCODE = 7'b0100011; localparam [2:0] SW_INSTR_FUNCT3 = 3'b010;
            localparam [6:0] ADDI_INSTR_OPCODE = 7'b0010011; localparam [2:0] ADDI_INSTR_FUNCT3 = 3'b000;
            localparam [6:0] SLTI_INSTR_OPCODE = 7'b0010011; localparam [2:0] SLTI_INSTR_FUNCT3 = 3'b010;
            localparam [6:0] SLTIU_INSTR_OPCODE = 7'b0010011; localparam [2:0] SLTIU_INSTR_FUNCT3 = 3'b011;
            localparam [6:0] XORI_INSTR_OPCODE = 7'b0010011; localparam [2:0] XORI_INSTR_FUNCT3 = 3'b100;
            localparam [6:0] ORI_INSTR_OPCODE = 7'b0010011; localparam [2:0] ORI_INSTR_FUNCT3 = 3'b110;
            localparam [6:0] ANDI_INSTR_OPCODE = 7'b0010011; localparam [2:0] ANDI_INSTR_FUNCT3 = 3'b111;
            localparam [6:0] SLLI_INSTR_OPCODE = 7'b0010011; localparam [2:0] SLLI_INSTR_FUNCT3 = 3'b001;
            localparam [6:0] SRLI_SRAI_INSTR_OPCODE = 7'b0010011; localparam [2:0] SRLI_SRAI_INSTR_FUNCT3 = 3'b101;  // Two instructions distinguished by an immediate bit, treated as a single instruction.
            localparam [6:0] ADD_SUB_INSTR_OPCODE = 7'b0110011; localparam [2:0] ADD_SUB_INSTR_FUNCT3 = 3'b000;  // Treated as a single instruction.
            localparam [6:0] SLL_INSTR_OPCODE = 7'b0110011; localparam [2:0] SLL_INSTR_FUNCT3 = 3'b001;
            localparam [6:0] SLT_INSTR_OPCODE = 7'b0110011; localparam [2:0] SLT_INSTR_FUNCT3 = 3'b010;
            localparam [6:0] SLTU_INSTR_OPCODE = 7'b0110011; localparam [2:0] SLTU_INSTR_FUNCT3 = 3'b011;
            localparam [6:0] XOR_INSTR_OPCODE = 7'b0110011; localparam [2:0] XOR_INSTR_FUNCT3 = 3'b100;
            localparam [6:0] SRL_SRA_INSTR_OPCODE = 7'b0110011; localparam [2:0] SRL_SRA_INSTR_FUNCT3 = 3'b101;  // Treated as a single instruction.
            localparam [6:0] OR_INSTR_OPCODE = 7'b0110011; localparam [2:0] OR_INSTR_FUNCT3 = 3'b110;
            localparam [6:0] AND_INSTR_OPCODE = 7'b0110011; localparam [2:0] AND_INSTR_FUNCT3 = 3'b111;
            //m4_instr(_, 32, I, 00011, 000, FENCE)
            //m4_instr(_, 32, I, 00011, 001, FENCE_I)
            //m4_instr(_, 32, I, 11100, 000, ECALL_EBREAK)  // Two instructions distinguished by an immediate bit, treated as a single instruction.
            //m4_instr(_, 32, I, 11100, 001, CSRRW)
            //m4_instr(_, 32, I, 11100, 010, CSRRS)
            //m4_instr(_, 32, I, 11100, 011, CSRRC)
            //m4_instr(_, 32, I, 11100, 101, CSRRWI)
            //m4_instr(_, 32, I, 11100, 110, CSRRSI)
            //m4_instr(_, 32, I, 11100, 111, CSRRCI)
            
            
            
            
              // Two instructions distinguished by an immediate bit, treated as a single instruction.
            
            
              // Two instructions distinguished by an immediate bit, treated as a single instruction.
              // Two instructions distinguished by an immediate bit, treated as a single instruction.
            
              // Two instructions distinguished by an immediate bit, treated as a single instruction.
            
            
            
            
            
            
            
            
            
            
            
            
            
            // RV32A and RV64A
            // NOT IMPLEMENTED. These are distinct in the func7 field.
            // RV32F and RV64F
            // NOT IMPLEMENTED.
            // RV32D and RV64D
            // NOT IMPLEMENTED.
      
      
         // ^---------------------
      //_\end_source
      `line 1262 "repos/warp-v/warp-v.tlv" 2
   
      // The program in an instruction memory.
      /*SV_plus*/
         logic [31:0] instrs [0:11-1];
      `line 798 "repos/warp-v/warp-v.tlv" 1   // Instantiated from repos/warp-v/warp-v.tlv, 1266 as: m4+indirect(M4_isa['_cnt10_prog'])
         /*SV_plus*/
            logic [40*8-1:0] instr_strs [0:11];
            
            // /=====================\
            // | Count to 10 Program |
            // \=====================/
            //
            
            // Add 1,2,3,...,10 (in that order).
            // Store incremental results in memory locations 0..9. (1, 3, 6, 10, ...)
            //
            // Regs:
            // 1: cnt
            // 2: ten
            // 3: out
            // 4: tmp
            // 5: offset
            // 6: store addr
            
            
      //_\end_source
      `line 1267 "repos/warp-v/warp-v.tlv" 2
   
   
      // /=========\
      // | The CPU |
      // \=========/
      
      assign L0_reset_a0 = reset;
   
      //_|fetch
         //_/instr
            //_@0
               assign FETCH_Instr_reset_a0 = L0_reset_a0;
            
               assign FETCH_Instr_fetch_a0 = 1'b1;  // always fetch
               //_?$fetch
   
                  // =====
                  // Fetch
                  // =====
   
                  assign FETCH_Instr_raw_a0[31:0] = instrs[FETCH_Instr_Pc_a0[5:2]];
               
            //_@0
               // A returning load clobbers the instruction.
               // (Could do this with lower latency. Right now it goes through memory pipeline $ANY, and
               //  it is non-speculative. Both could easily be fixed.)
               assign FETCH_Instr_returning_ld_a0 = MEM_Data_valid_ld_a1;
               
               // =======
               // Next PC
               // =======
               
               assign FETCH_Instr_Pc_n1[31:2] =
                  FETCH_Instr_reset_a0 ? 30'b0 :
                  FETCH_Instr_valid_pred_taken_branch_a1 ? FETCH_Instr_branch_target_a1 :
                  FETCH_Instr_valid_mispred_branch_a1 ? FETCH_Instr_branch_target_a1 :
                  FETCH_Instr_valid_jump_a1 ? FETCH_Instr_jump_target_a1 :
                  FETCH_Instr_good_path_trap_a2 ? 0 :  // TODO: trap target?
                  FETCH_Instr_replay_a1 ? FETCH_Instr_Pc_a1 :
                  FETCH_Instr_returning_ld_a0 ? FETCH_Instr_Pc_a0[31:2] :  // Returning load, so next PC is the previous next PC (unless there was a branch that wasn't visible yet)
                           FETCH_Instr_Pc_a0 + 30'b1;
               
            //_@0
   
               // ======
               // DECODE
               // ======
   
               // Decode of the fetched instruction
               assign FETCH_Instr_valid_decode_a0 = FETCH_Instr_fetch_a0;  // Always decode if we fetch.
               `line 982 "repos/warp-v/warp-v.tlv" 1   // Instantiated from repos/warp-v/warp-v.tlv, 1317 as: m4+indirect(M4_isa['_decode'])
                  //_?$valid_decode
               
                     // =================================
               
                     // Extract fields of $raw (instruction) into $raw_<field>[x:0].
                     assign {FETCH_Instr_raw_funct7_a0[6:0], FETCH_Instr_raw_rs2_a0[4:0], FETCH_Instr_raw_rs1_a0[4:0], FETCH_Instr_raw_funct3_a0[2:0], FETCH_Instr_raw_rd_a0[4:0], FETCH_Instr_raw_op5_a0[4:0], FETCH_Instr_raw_op2_a0[1:0]} = FETCH_Instr_raw_a0;
                     `BOGUS_USE(FETCH_Instr_raw_funct7_a0 FETCH_Instr_raw_op2_a0)  // Delete once its used.
                     // Extract immediate fields into type-specific signals.
                     // (User ISA Manual 2.2, Fig. 2.4)
                     assign FETCH_Instr_raw_i_imm_a0[31:0] = {{21{FETCH_Instr_raw_a0[31]}}, FETCH_Instr_raw_a0[30:20]};
                     assign FETCH_Instr_raw_s_imm_a0[31:0] = {{21{FETCH_Instr_raw_a0[31]}}, FETCH_Instr_raw_a0[30:25], FETCH_Instr_raw_a0[11:7]};
                     assign FETCH_Instr_raw_b_imm_a0[31:0] = {{20{FETCH_Instr_raw_a0[31]}}, FETCH_Instr_raw_a0[7], FETCH_Instr_raw_a0[30:25], FETCH_Instr_raw_a0[11:8], 1'b0};
                     assign FETCH_Instr_raw_u_imm_a0[31:0] = {FETCH_Instr_raw_a0[31:12], {12{1'b0}}};
                     //$raw_j_imm[31:0] = {{12{$raw[31]}}, $raw[19:12], $raw[20], $raw[30:21], 1'b0};
                     // Extract other type/instruction-specific fields.
                     assign FETCH_Instr_raw_shamt_a0[6:0] = FETCH_Instr_raw_a0[26:20];
                     assign FETCH_Instr_raw_aq_a0 = FETCH_Instr_raw_a0[26];
                     assign FETCH_Instr_raw_rl_a0 = FETCH_Instr_raw_a0[25];
                     assign FETCH_Instr_raw_rs3_a0[4:0] = FETCH_Instr_raw_a0[31:27];
                     assign FETCH_Instr_raw_rm_a0[2:0] = FETCH_Instr_raw_funct3_a0;
                     `BOGUS_USE(FETCH_Instr_raw_shamt_a0 FETCH_Instr_raw_aq_a0 FETCH_Instr_raw_rl_a0 FETCH_Instr_raw_rs3_a0 FETCH_Instr_raw_rm_a0)  // Avoid "unused" messages. Remove these as they become used.
               
                     // Instruction type decode
                     /*SV_plus*/
                        assign FETCH_Instr_is_i_type_a0 = INSTR_TYPE_I_MASK[FETCH_Instr_raw_op5_a0]; assign FETCH_Instr_is_r_type_a0 = INSTR_TYPE_R_MASK[FETCH_Instr_raw_op5_a0]; assign FETCH_Instr_is_ri_type_a0 = INSTR_TYPE_RI_MASK[FETCH_Instr_raw_op5_a0]; assign FETCH_Instr_is_r4_type_a0 = INSTR_TYPE_R4_MASK[FETCH_Instr_raw_op5_a0]; assign FETCH_Instr_is_s_type_a0 = INSTR_TYPE_S_MASK[FETCH_Instr_raw_op5_a0]; assign FETCH_Instr_is_b_type_a0 = INSTR_TYPE_B_MASK[FETCH_Instr_raw_op5_a0]; assign FETCH_Instr_is_j_type_a0 = INSTR_TYPE_J_MASK[FETCH_Instr_raw_op5_a0]; assign FETCH_Instr_is_u_type_a0 = INSTR_TYPE_U_MASK[FETCH_Instr_raw_op5_a0]; assign FETCH_Instr_is___type_a0 = INSTR_TYPE___MASK[FETCH_Instr_raw_op5_a0]; 
               
                     // Instruction decode.
                     `line 974 "repos/warp-v/warp-v.tlv" 1   // Instantiated from repos/warp-v/warp-v.tlv, 1009 as: m4+riscv_decode_expr()
                        assign FETCH_Instr_is_lui_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01101;
                        assign FETCH_Instr_is_auipc_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00101;
                        assign FETCH_Instr_is_jal_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11011;
                        assign FETCH_Instr_is_jalr_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11001 && FETCH_Instr_raw_funct3_a0 == 3'b000;
                        assign FETCH_Instr_is_beq_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b000;
                        assign FETCH_Instr_is_bne_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b001;
                        assign FETCH_Instr_is_blt_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b100;
                        assign FETCH_Instr_is_bge_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b101;
                        assign FETCH_Instr_is_bltu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b110;
                        assign FETCH_Instr_is_bgeu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b11000 && FETCH_Instr_raw_funct3_a0 == 3'b111;
                        assign FETCH_Instr_is_lb_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b000;
                        assign FETCH_Instr_is_lh_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b001;
                        assign FETCH_Instr_is_lw_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b010;
                        assign FETCH_Instr_is_lbu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b100;
                        assign FETCH_Instr_is_lhu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00000 && FETCH_Instr_raw_funct3_a0 == 3'b101;
                        assign FETCH_Instr_is_sb_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01000 && FETCH_Instr_raw_funct3_a0 == 3'b000;
                        assign FETCH_Instr_is_sh_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01000 && FETCH_Instr_raw_funct3_a0 == 3'b001;
                        assign FETCH_Instr_is_sw_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01000 && FETCH_Instr_raw_funct3_a0 == 3'b010;
                        assign FETCH_Instr_is_addi_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b000;
                        assign FETCH_Instr_is_slti_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b010;
                        assign FETCH_Instr_is_sltiu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b011;
                        assign FETCH_Instr_is_xori_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b100;
                        assign FETCH_Instr_is_ori_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b110;
                        assign FETCH_Instr_is_andi_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b111;
                        assign FETCH_Instr_is_slli_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b001;
                        assign FETCH_Instr_is_srli_srai_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b00100 && FETCH_Instr_raw_funct3_a0 == 3'b101;
                        assign FETCH_Instr_is_add_sub_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b000;
                        assign FETCH_Instr_is_sll_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b001;
                        assign FETCH_Instr_is_slt_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b010;
                        assign FETCH_Instr_is_sltu_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b011;
                        assign FETCH_Instr_is_xor_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b100;
                        assign FETCH_Instr_is_srl_sra_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b101;
                        assign FETCH_Instr_is_or_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b110;
                        assign FETCH_Instr_is_and_instr_a0 = FETCH_Instr_raw_op5_a0 == 5'b01100 && FETCH_Instr_raw_funct3_a0 == 3'b111;
                        
                     //_\end_source
                     `line 1010 "repos/warp-v/warp-v.tlv" 2
               
                     assign FETCH_Instr_illegal_a0 = 1'b1 && ! FETCH_Instr_is_lui_instr_a0 && ! FETCH_Instr_is_auipc_instr_a0 && ! FETCH_Instr_is_jal_instr_a0 && ! FETCH_Instr_is_jalr_instr_a0 && ! FETCH_Instr_is_beq_instr_a0 && ! FETCH_Instr_is_bne_instr_a0 && ! FETCH_Instr_is_blt_instr_a0 && ! FETCH_Instr_is_bge_instr_a0 && ! FETCH_Instr_is_bltu_instr_a0 && ! FETCH_Instr_is_bgeu_instr_a0 && ! FETCH_Instr_is_lb_instr_a0 && ! FETCH_Instr_is_lh_instr_a0 && ! FETCH_Instr_is_lw_instr_a0 && ! FETCH_Instr_is_lbu_instr_a0 && ! FETCH_Instr_is_lhu_instr_a0 && ! FETCH_Instr_is_sb_instr_a0 && ! FETCH_Instr_is_sh_instr_a0 && ! FETCH_Instr_is_sw_instr_a0 && ! FETCH_Instr_is_addi_instr_a0 && ! FETCH_Instr_is_slti_instr_a0 && ! FETCH_Instr_is_sltiu_instr_a0 && ! FETCH_Instr_is_xori_instr_a0 && ! FETCH_Instr_is_ori_instr_a0 && ! FETCH_Instr_is_andi_instr_a0 && ! FETCH_Instr_is_slli_instr_a0 && ! FETCH_Instr_is_srli_srai_instr_a0 && ! FETCH_Instr_is_add_sub_instr_a0 && ! FETCH_Instr_is_sll_instr_a0 && ! FETCH_Instr_is_slt_instr_a0 && ! FETCH_Instr_is_sltu_instr_a0 && ! FETCH_Instr_is_xor_instr_a0 && ! FETCH_Instr_is_srl_sra_instr_a0 && ! FETCH_Instr_is_or_instr_a0 && ! FETCH_Instr_is_and_instr_a0;
                     assign FETCH_Instr_jump_a0 = FETCH_Instr_is_jalr_instr_a0;  // "Jump" in this code means absolute. "Jump" in RISC-V means unconditional.
                     assign FETCH_Instr_conditional_branch_a0 = FETCH_Instr_is_b_type_a0;
                     assign FETCH_Instr_branch_a0 = FETCH_Instr_is_b_type_a0 || FETCH_Instr_is_j_type_a0;
                     assign FETCH_Instr_ld_a0 = FETCH_Instr_raw_a0[6:3] == 4'b0;
                     assign FETCH_Instr_st_a0 = FETCH_Instr_is_s_type_a0;
                     `BOGUS_USE(FETCH_Instr_is___type_a0 FETCH_Instr_is_u_type_a0)
               
                     // Output signals.
                     for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_Src wire L1_is_reg_a0; wire [4:0] L1_reg_a0; //_/src
                        // Reg valid for this source, based on instruction type.
                        assign L1_is_reg_a0 = FETCH_Instr_is_r_type_a0 || FETCH_Instr_is_r4_type_a0 || (FETCH_Instr_is_i_type_a0 && (src == 1)) || FETCH_Instr_is_ri_type_a0 || FETCH_Instr_is_s_type_a0 || FETCH_Instr_is_b_type_a0;
                        assign L1_reg_a0[4:0] = (src == 1) ? FETCH_Instr_raw_rs1_a0 : FETCH_Instr_raw_rs2_a0; end
                          
                     // For debug.
                     assign FETCH_Instr_mnemonic_a0[10*8-1:0] = FETCH_Instr_is_lui_instr_a0 ? "LUI       " : FETCH_Instr_is_auipc_instr_a0 ? "AUIPC     " : FETCH_Instr_is_jal_instr_a0 ? "JAL       " : FETCH_Instr_is_jalr_instr_a0 ? "JALR      " : FETCH_Instr_is_beq_instr_a0 ? "BEQ       " : FETCH_Instr_is_bne_instr_a0 ? "BNE       " : FETCH_Instr_is_blt_instr_a0 ? "BLT       " : FETCH_Instr_is_bge_instr_a0 ? "BGE       " : FETCH_Instr_is_bltu_instr_a0 ? "BLTU      " : FETCH_Instr_is_bgeu_instr_a0 ? "BGEU      " : FETCH_Instr_is_lb_instr_a0 ? "LB        " : FETCH_Instr_is_lh_instr_a0 ? "LH        " : FETCH_Instr_is_lw_instr_a0 ? "LW        " : FETCH_Instr_is_lbu_instr_a0 ? "LBU       " : FETCH_Instr_is_lhu_instr_a0 ? "LHU       " : FETCH_Instr_is_sb_instr_a0 ? "SB        " : FETCH_Instr_is_sh_instr_a0 ? "SH        " : FETCH_Instr_is_sw_instr_a0 ? "SW        " : FETCH_Instr_is_addi_instr_a0 ? "ADDI      " : FETCH_Instr_is_slti_instr_a0 ? "SLTI      " : FETCH_Instr_is_sltiu_instr_a0 ? "SLTIU     " : FETCH_Instr_is_xori_instr_a0 ? "XORI      " : FETCH_Instr_is_ori_instr_a0 ? "ORI       " : FETCH_Instr_is_andi_instr_a0 ? "ANDI      " : FETCH_Instr_is_slli_instr_a0 ? "SLLI      " : FETCH_Instr_is_srli_srai_instr_a0 ? "SRLI_SRAI " : FETCH_Instr_is_add_sub_instr_a0 ? "ADD_SUB   " : FETCH_Instr_is_sll_instr_a0 ? "SLL       " : FETCH_Instr_is_slt_instr_a0 ? "SLT       " : FETCH_Instr_is_sltu_instr_a0 ? "SLTU      " : FETCH_Instr_is_xor_instr_a0 ? "XOR       " : FETCH_Instr_is_srl_sra_instr_a0 ? "SRL_SRA   " : FETCH_Instr_is_or_instr_a0 ? "OR        " : FETCH_Instr_is_and_instr_a0 ? "AND       " :  "ILLEGAL   ";
                     `BOGUS_USE(FETCH_Instr_mnemonic_a0)
                  // Condition signals must not themselves be conditioned (currently).
                  assign FETCH_Instr_valid_decode_branch_a0 = FETCH_Instr_valid_decode_a0 && FETCH_Instr_branch_a0;
                  assign FETCH_Instr_dest_reg_a0[4:0] = FETCH_Instr_returning_ld_a0 ? FETCH_Instr_returning_ld_dest_reg_a0 : FETCH_Instr_raw_rd_a0;
                  assign FETCH_Instr_dest_reg_valid_a0 = ((FETCH_Instr_valid_decode_a0 && ! FETCH_Instr_is_s_type_a0 && ! FETCH_Instr_is_b_type_a0) || FETCH_Instr_returning_ld_a0) &&
                                    | FETCH_Instr_dest_reg_a0;   // r0 not valid.
                  // Actually load.
                  assign FETCH_Instr_spec_ld_a0 = FETCH_Instr_valid_decode_a0 && FETCH_Instr_ld_a0;
                  
               //_\end_source
               `line 1318 "repos/warp-v/warp-v.tlv" 2
               
               // Returning load doesn't decode the instruction. Provide value to force for dest reg. 
               assign FETCH_Instr_returning_ld_dest_reg_a0[4:0] = MEM_Data_dest_reg_a1;
            
            `line 1233 "repos/warp-v/warp-v.tlv" 1   // Instantiated from repos/warp-v/warp-v.tlv, 1322 as: m4+indirect(['branch_pred_']M4_BRANCH_PRED)
               //_@0
                  assign FETCH_Instr_pred_taken_a0 = 1'b0;
            //_\end_source
            `line 1323 "repos/warp-v/warp-v.tlv" 2
            
            //_@0
               // ======
               // Reg Rd
               // ======
               
               //_/regs
               for (src = 1; src <= 2; src++) begin : L1b_FETCH_Instr_Src wire L1_is_reg_condition_a0; wire [31:0] L1_reg_value_a0; //_/src
                  assign L1_is_reg_condition_a0 = L1_FETCH_Instr_Src[src].L1_is_reg_a0 && FETCH_Instr_valid_decode_a0;
                  //_?$is_reg_condition
                     assign L1_reg_value_a0[31:0] =
                        
                        // Bypass stages:
                        
                        
                        
                        FETCH_Instr_Regs_Value_a0[L1_FETCH_Instr_Src[src].L1_reg_a0];
                  assign FETCH_Instr_Src_replay_a0[src] = L1_is_reg_condition_a0 && FETCH_Instr_Regs_next_pending_a1[L1_FETCH_Instr_Src[src].L1_reg_a0]; end
               assign FETCH_Instr_replay_a0 = | FETCH_Instr_Src_replay_a0 || (FETCH_Instr_dest_reg_valid_a0 && FETCH_Instr_Regs_next_pending_a1[FETCH_Instr_dest_reg_a0]);
            
            
            // =======
            // Execute
            // =======
            `line 1037 "repos/warp-v/warp-v.tlv" 1   // Instantiated from repos/warp-v/warp-v.tlv, 1347 as: m4+indirect(M4_isa['_exe'], @M4_EXECUTE_STAGE, @M4_RESULT_STAGE)
               //_@0
                  //_?$valid_decode_branch
                     assign FETCH_Instr_branch_target_a0[31:2] = FETCH_Instr_Pc_a0 + FETCH_Instr_raw_b_imm_a0[31:2];
                     // TODO: Deal with misaligned address.
               //_@0
                  // Execution.
                  assign FETCH_Instr_valid_exe_a0 = FETCH_Instr_valid_decode_a0; // Execute if we decoded.
                  
                  // Compute results for each instruction, independent of decode (power-hungry, but fast).
                  //_?$valid_exe
                     assign FETCH_Instr_equal_a0 = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 == L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
                  //_?$valid_branch
                     assign FETCH_Instr_taken_a0 =
                        FETCH_Instr_is_j_type_a0 ||
                        (FETCH_Instr_is_beq_instr_a0 && FETCH_Instr_equal_a0) ||
                        (FETCH_Instr_is_bne_instr_a0 && ! FETCH_Instr_equal_a0) ||
                        ((FETCH_Instr_is_blt_instr_a0 || FETCH_Instr_is_bltu_instr_a0 || FETCH_Instr_is_bge_instr_a0 || FETCH_Instr_is_bgeu_instr_a0) &&
                         ((FETCH_Instr_is_bge_instr_a0 || FETCH_Instr_is_bgeu_instr_a0) ^
                          ({(FETCH_Instr_is_blt_instr_a0 ^ L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31]), L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31-1:0]} <
                           {(FETCH_Instr_is_blt_instr_a0 ^ L1b_FETCH_Instr_Src[2].L1_reg_value_a0[31]), L1b_FETCH_Instr_Src[2].L1_reg_value_a0[31-1:0]}
                          )
                         )
                        );
                  //_?$valid_jump
                     assign FETCH_Instr_jump_target_a0[31:2] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0[31:2] + FETCH_Instr_raw_i_imm_a0[31:2];
                     // TODO: This assumes aligned addresses. Must deal with zeroing of byte bit and misaligned address.
                  //_?$valid_exe
                     // Compute each individual instruction result, combined per-instruction by a macro.
                     
                     assign FETCH_Instr_lui_rslt_a0[31:0] = FETCH_Instr_raw_u_imm_a0;
                     assign FETCH_Instr_auipc_rslt_a0[31:0] = {FETCH_Instr_Pc_a0, 2'b0} + FETCH_Instr_raw_u_imm_a0;
                     assign FETCH_Instr_jal_rslt_a0[31:0] = {FETCH_Instr_Pc_a0, 2'b0} + 4;
                     assign FETCH_Instr_jalr_rslt_a0[31:0] = {FETCH_Instr_Pc_a0, 2'b0} + 4;
                     assign FETCH_Instr_lb_rslt_a0[31:0] = 32'b0;
                     assign FETCH_Instr_lh_rslt_a0[31:0] = 32'b0;
                     assign FETCH_Instr_lw_rslt_a0[31:0] = FETCH_Instr_returning_ld_data_a0;
                     assign FETCH_Instr_lbu_rslt_a0[31:0] = 32'b0;
                     assign FETCH_Instr_lhu_rslt_a0[31:0] = 32'b0;
                     assign FETCH_Instr_addi_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 + FETCH_Instr_raw_i_imm_a0;  // Note: this has its own adder; could share w/ add/sub.
                     assign FETCH_Instr_slti_rslt_a0[31:0] = (L1b_FETCH_Instr_Src[1].L1_reg_value_a0 < FETCH_Instr_raw_i_imm_a0) ? 1 : 0 ;
                     assign FETCH_Instr_sltiu_rslt_a0[31:0] = 32'b0;
                     assign FETCH_Instr_xori_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 ^ FETCH_Instr_raw_i_imm_a0;
                     assign FETCH_Instr_ori_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 | FETCH_Instr_raw_i_imm_a0;
                     assign FETCH_Instr_andi_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 & FETCH_Instr_raw_i_imm_a0;
                     assign FETCH_Instr_slli_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 << L1b_FETCH_Instr_Src[2].L1_reg_value_a0[4:0];
                     assign FETCH_Instr_srli_srai_rslt_a0[31:0] = 32'b0;
                     assign FETCH_Instr_add_sub_rslt_a0[31:0] =  L1b_FETCH_Instr_Src[1].L1_reg_value_a0 + L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
                     assign FETCH_Instr_sll_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 << L1b_FETCH_Instr_Src[2].L1_reg_value_a0[4:0];
                     assign FETCH_Instr_slt_rslt_a0[31:0] = (L1b_FETCH_Instr_Src[1].L1_reg_value_a0 < L1b_FETCH_Instr_Src[2].L1_reg_value_a0) ? 1 : 0;
                     assign FETCH_Instr_sltu_rslt_a0[31:0] = 32'b0;
                     assign FETCH_Instr_xor_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 ^ L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
                     assign FETCH_Instr_srl_sra_rslt_a0[31:0] = 32'b0;
                     assign FETCH_Instr_or_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 | L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
                     assign FETCH_Instr_and_rslt_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 & L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
               //_@0
                  //_?$valid_ld_st
                     assign FETCH_Instr_addr_a0[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a0 + (FETCH_Instr_ld_a0 ? FETCH_Instr_raw_i_imm_a0 : FETCH_Instr_raw_s_imm_a0);
                  //_?$valid_st
                     assign FETCH_Instr_st_value_a0[31:0] = L1b_FETCH_Instr_Src[2].L1_reg_value_a0;
            
               //_@0
                  // Mux the correct result.
                  `line 977 "repos/warp-v/warp-v.tlv" 1   // Instantiated from repos/warp-v/warp-v.tlv, 1099 as: m4+riscv_rslt_mux_expr()
                     assign FETCH_Instr_rslt_a0[31:0] = 
                         FETCH_Instr_returning_ld_a0 ? FETCH_Instr_returning_ld_data_a0 :
                         32'b0 |
                         ({32{FETCH_Instr_is_lui_instr_a0}} & FETCH_Instr_lui_rslt_a0) |
                         ({32{FETCH_Instr_is_auipc_instr_a0}} & FETCH_Instr_auipc_rslt_a0) |
                         ({32{FETCH_Instr_is_jal_instr_a0}} & FETCH_Instr_jal_rslt_a0) |
                         ({32{FETCH_Instr_is_jalr_instr_a0}} & FETCH_Instr_jalr_rslt_a0) |
                         ({32{FETCH_Instr_is_lb_instr_a0}} & FETCH_Instr_lb_rslt_a0) |
                         ({32{FETCH_Instr_is_lh_instr_a0}} & FETCH_Instr_lh_rslt_a0) |
                         ({32{FETCH_Instr_is_lw_instr_a0}} & FETCH_Instr_lw_rslt_a0) |
                         ({32{FETCH_Instr_is_lbu_instr_a0}} & FETCH_Instr_lbu_rslt_a0) |
                         ({32{FETCH_Instr_is_lhu_instr_a0}} & FETCH_Instr_lhu_rslt_a0) |
                         ({32{FETCH_Instr_is_addi_instr_a0}} & FETCH_Instr_addi_rslt_a0) |
                         ({32{FETCH_Instr_is_slti_instr_a0}} & FETCH_Instr_slti_rslt_a0) |
                         ({32{FETCH_Instr_is_sltiu_instr_a0}} & FETCH_Instr_sltiu_rslt_a0) |
                         ({32{FETCH_Instr_is_xori_instr_a0}} & FETCH_Instr_xori_rslt_a0) |
                         ({32{FETCH_Instr_is_ori_instr_a0}} & FETCH_Instr_ori_rslt_a0) |
                         ({32{FETCH_Instr_is_andi_instr_a0}} & FETCH_Instr_andi_rslt_a0) |
                         ({32{FETCH_Instr_is_slli_instr_a0}} & FETCH_Instr_slli_rslt_a0) |
                         ({32{FETCH_Instr_is_srli_srai_instr_a0}} & FETCH_Instr_srli_srai_rslt_a0) |
                         ({32{FETCH_Instr_is_add_sub_instr_a0}} & FETCH_Instr_add_sub_rslt_a0) |
                         ({32{FETCH_Instr_is_sll_instr_a0}} & FETCH_Instr_sll_rslt_a0) |
                         ({32{FETCH_Instr_is_slt_instr_a0}} & FETCH_Instr_slt_rslt_a0) |
                         ({32{FETCH_Instr_is_sltu_instr_a0}} & FETCH_Instr_sltu_rslt_a0) |
                         ({32{FETCH_Instr_is_xor_instr_a0}} & FETCH_Instr_xor_rslt_a0) |
                         ({32{FETCH_Instr_is_srl_sra_instr_a0}} & FETCH_Instr_srl_sra_rslt_a0) |
                         ({32{FETCH_Instr_is_or_instr_a0}} & FETCH_Instr_or_rslt_a0) |
                         ({32{FETCH_Instr_is_and_instr_a0}} & FETCH_Instr_and_rslt_a0);
                  //_\end_source
                  `line 1100 "repos/warp-v/warp-v.tlv" 2
               
            //_\end_source
            `line 1348 "repos/warp-v/warp-v.tlv" 2
                  
            //_@0
   
               // ============
               // Control Flow
               // ============
               
               // Terminology:
               // Instruction: An instruction, as viewed by the CPU pipeline (i.e. ld and ld_return are separate instructions).
               // ISA Instruction: An instruction, as defined by the ISA.
               // Squash: Do not commit the results of this instruction.
               // Good Path: On the proper flow of execution of the program.
               // Redirect: Adjust the PC from the predicted next-PC.
               // Redirect Shadow: Between the instruction causing the redirect and the redirect target instruction.
               // Commit: Results are made visible to subsequent instructions.
               // Retire: Commit and completes an ISA instruction.
               
               // Instruction control flow characterization:
               //
               // Traps include:
               //   o illegal instructions
               //   o misaligned PC
               //   o ...
               assign FETCH_Instr_trap_a0 = FETCH_Instr_illegal_a0;  // TODO: || $misaligned_pc...
               assign FETCH_Instr_mispred_branch_a0 = FETCH_Instr_branch_a0 && ! (FETCH_Instr_conditional_branch_a0 && ! FETCH_Instr_taken_a0);
               assign FETCH_Instr_redirecting_squash_a0 = FETCH_Instr_replay_a0 || FETCH_Instr_trap_a0;  // Instruction would squash and redirect the PC (if good-path).
               assign FETCH_Instr_in_redirect_shadow_a0 = | FETCH_Instr_RedirectShadowCnt_a0;  // Instruction is in the shadow of a redirect (not the cause of it).
   
               // Good path & squash.
               assign FETCH_Instr_good_path_a0 = FETCH_Instr_valid_exe_a0 && ! FETCH_Instr_in_redirect_shadow_a0;  // This instruction is on the good path (though it may be replayed).
               assign FETCH_Instr_squash_a0 = ! FETCH_Instr_good_path_a0 || FETCH_Instr_redirecting_squash_a0;  // Instruction will not commit results.
               assign FETCH_Instr_commit_a0 = ! FETCH_Instr_squash_a0;
   
               // Trap conditions conditioned upon good-path.
               assign FETCH_Instr_good_path_illegal_a0 = FETCH_Instr_illegal_a0 && FETCH_Instr_good_path_a0;
               assign FETCH_Instr_good_path_trap_a0 = FETCH_Instr_trap_a0 && FETCH_Instr_good_path_a0;
               `BOGUS_USE(FETCH_Instr_good_path_illegal_a0)
               // Signals conditioned upon commit.
               assign FETCH_Instr_valid_jump_a0 = FETCH_Instr_jump_a0 && FETCH_Instr_commit_a0;
               assign FETCH_Instr_valid_branch_a0 = FETCH_Instr_branch_a0 && FETCH_Instr_commit_a0;
               assign FETCH_Instr_valid_pred_taken_branch_a0 = FETCH_Instr_valid_branch_a0 && FETCH_Instr_pred_taken_a0;
               assign FETCH_Instr_valid_mispred_branch_a0 = FETCH_Instr_mispred_branch_a0 && FETCH_Instr_commit_a0;
               assign FETCH_Instr_valid_dest_reg_valid_a0 = FETCH_Instr_dest_reg_valid_a0 && FETCH_Instr_commit_a0;
               assign FETCH_Instr_valid_ld_a0 = FETCH_Instr_ld_a0 && FETCH_Instr_commit_a0;
               assign FETCH_Instr_valid_st_a0 = FETCH_Instr_st_a0 && FETCH_Instr_commit_a0;
               assign FETCH_Instr_valid_ld_st_a0 = FETCH_Instr_valid_ld_a0 || FETCH_Instr_valid_st_a0;
   
               // Squash. Keep a count of the number of cycles remaining in the shadow of a mispredict.
               assign FETCH_Instr_RedirectShadowCnt_n1[2:0] =
                  FETCH_Instr_reset_a0                ? 3'b0 :
                  FETCH_Instr_valid_pred_taken_branch_a0 ? 1 :
                  FETCH_Instr_valid_mispred_branch_a0 ? 1 :
                  FETCH_Instr_valid_jump_a0           ? 1 :
                  FETCH_Instr_good_path_trap_a0       ? 2 :
                  FETCH_Instr_replay_a0               ? 2 - 3'b1 :
                  FETCH_Instr_RedirectShadowCnt_a0 == 3'b0    ? 3'b0 :
                                          FETCH_Instr_RedirectShadowCnt_a0 - 3'b1;
                                          
               assign FETCH_Instr_returning_ld_data_a0[31:0] = MEM_Data_ld_rslt_a1;
      `line 1178 "repos/warp-v/warp-v.tlv" 1   // Instantiated from repos/warp-v/warp-v.tlv, 1407 as: m4+fixed_latency_fake_memory(/top, 0)
         //_|fetch
            //_/instr
               // ====
               // Load
               // ====
               
               //_/mem
               //_?$spec_ld
                  //_@0
                     assign FETCH_Instr_ld_rslt_a0[31:0] = FETCH_Instr_Mem_Word_a0[FETCH_Instr_addr_a0[4:0]];
               
               // Array writes are not currently permitted to use assignment
               // syntax, so \always_comb is used, and this must be outside of
               // when conditions, so we need to use if. <<1 because no <= support
               // in this context. (This limitation will be lifted.)
      
               //_@0
                  // =====
                  // Store
                  // =====
      
                  /*SV_plus*/
                     always @ (posedge clk) begin
                        if (FETCH_Instr_valid_st_a0)
                           FETCH_Instr_Mem_Word_n1[FETCH_Instr_addr_a0[4:0]][31:0] = FETCH_Instr_st_value_a0;
                     end
      
         // Return loads in |mem pipeline. We just hook up the |mem pipeline to the |fetch pipeline w/ the
         // right alignment.
         //_|mem
            //_/data
               //_@0
                  assign {MEM_Data_dest_reg_a0[4:0], MEM_Data_ld_rslt_a0[31:0], MEM_Data_valid_ld_a0} = {FETCH_Instr_dest_reg_a0, FETCH_Instr_ld_rslt_a0, FETCH_Instr_valid_ld_a0};
      //_\end_source
      `line 1408 "repos/warp-v/warp-v.tlv" 2
      //_|fetch
         //_/instr
            //_@0
               // =========
               // Reg Write
               // =========
   
               assign FETCH_Instr_reg_write_a0 = FETCH_Instr_reset_a0 ? 1'b0 : FETCH_Instr_valid_dest_reg_valid_a0;
               /*SV_plus*/
                  always @ (posedge clk) begin
                     if (FETCH_Instr_reg_write_a0)
                        FETCH_Instr_Regs_Value_n1[FETCH_Instr_dest_reg_a0][31:0] = FETCH_Instr_rslt_a0;
                  end
               
               // =======================
               // For Formal Verification
               // =======================
               // Currenty we fetch an instruction every cycle, and squash is the only
               //   mechanism to avoid retiring. Also loads issue in two parts, the $ld and the
               //   $returning_ld.
               assign FETCH_Instr_retire_a0 = FETCH_Instr_commit_a0 && ! FETCH_Instr_ld_a0;
               `BOGUS_USE(FETCH_Instr_retire_a0 FETCH_Instr_good_path_trap_a0)
            
            // There's no bypass on pending, so we must write the same cycle we read.
            //_@0
               for (regs = 1; regs <= 31; regs++) begin : L1b_FETCH_Instr_Regs wire L1_reg_match_a0; //_/regs
                  assign L1_reg_match_a0 = FETCH_Instr_dest_reg_a0 == regs;
                  assign FETCH_Instr_Regs_next_pending_a0[regs] =  // Should be state, but need to consume prior to flop, which SandPiper doesn't support, yet.
                     FETCH_Instr_reset_a0 ? 1'b0 :
                     // set for loads
                     FETCH_Instr_valid_ld_a0 && L1_reg_match_a0   ? 1'b1 :
                     // clear when load returns
                     FETCH_Instr_returning_ld_a0 && L1_reg_match_a0 ? 1'b0 :
                                  FETCH_Instr_Regs_next_pending_a1[regs]; end
      
   //_\end_source
   `line 1455 "repos/warp-v/warp-v.tlv" 2

   
   // Assert these to end simulation (before Makerchip cycle limit).
   assign passed = ! reset;
   assign failed = ! reset; endgenerate
//_\SV
   endmodule
