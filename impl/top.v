//Generated by SandPiper(TM) 1.9-2018/02/11-beta
   // -----------------------------------------------------------------------------
   // Copyright (c) 2018, Steven F. Hoover
   // 
   // Redistribution and use in source and binary forms, with or without
   // modification, are permitted provided that the following conditions are met:
   // 
   //     * Redistributions of source code must retain the above copyright notice,
   //       this list of conditions and the following disclaimer.
   //     * Redistributions in binary form must reproduce the above copyright
   //       notice, this list of conditions and the following disclaimer in the
   //       documentation and/or other materials provided with the distribution.
   //     * The name Steven F. Hoover
   //       may not be used to endorse or promote products derived from this software
   //       without specific prior written permission.
   // 
   // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
   // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   // -----------------------------------------------------------------------------
   // This code is mastered in https://github.com/stevehoover/warp-v.git



//---------------------------------------------------
//`include "sp_verilog.vh" //_\SV
// File included by SandPiper-generated code for the default project configuration.


//----------------------------------------------------
//`include "sandpiper.vh"
// Note, these have no SP prefix, so collisions are possible.
     
`ifndef SANDPIPER_VH
`define SANDPIPER_VH

`ifdef WHEN
   // Make sure user definition does not collide.
   !!!ERROR: WHEN macro already defined
`else
   `ifdef SP_PHYS
      // Phys compilation disabled X-injection.
      `define WHEN(valid_sig)
   `else
      // Inject X.
      `define WHEN(valid_sig) !valid_sig ? 'x :
   `endif
`endif

`endif


`define BOGUS_USE(ignore)
//---------------------------------------------------



// Latch macros.  Inject 'x in simulation for clk === 'x.

// A-phase latch.
`ifdef SP_PHYS
`define TLV_LATCH(in, out, clk) \
always @ (in, clk) begin        \
 if (clk === 1'b1)             \
   out <= in;                  \
 else if (clk === 1'bx)        \
   out <= 'x;                  \
end
`else
`define TLV_LATCH(in, out, clk) always @ (in, clk) if (clk == 1'b1) out <= in;
`endif  // SP_PHYS

// B-phase latch.
`ifdef SP_PHYS
`define TLV_BLATCH(out, in, clk) \
always @ (in, clk) begin         \
 if (!clk === 1'b1)             \
   out <= in;                   \
 else if (!clk === 1'bx)        \
   out <= 'x;                   \
end
`else
`define TLV_BLATCH(out, in, clk) always @ (in, clk) if (!clk == 1'b1) out <= in;
`endif  // SP_PHYS

//---------------------------------------------------




//_\source top.tlv 873
//_\SV
/* verilator lint_on WIDTH */  // Let's be strict about bit widths.






//_\source top.tlv 2131
//_\SV
module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    /* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  /* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */

//_\source top.tlv 2133



//----------------------------------------------------------
//`include "top_gen.sv" //_\TLV
// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /usr/local/mono/sandpiper/distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


//`include "sandpiper_gen.vh" (empty file)


genvar bank, mem, regs, src;


//
// Signals declared top-level.
//

// For |fetch/instr$BranchState.
wire [1:0] FETCH_Instr_BranchState_a1;
reg  [1:0] FETCH_Instr_BranchState_a2;
reg  [1:1] FETCH_Instr_BranchState_a3;

// For |fetch/instr$Cnt.
wire [7:0] FETCH_Instr_Cnt_n2;
reg  [7:0] FETCH_Instr_Cnt_n1;

// For |fetch/instr$GoodPathMask.
wire [3+1:0] FETCH_Instr_GoodPathMask_n1;
reg  [3+1:0] FETCH_Instr_GoodPathMask_a0;
reg  [3+1:1] FETCH_Instr_GoodPathMask_a1;

// For |fetch/instr$Pc.
wire [31:2] FETCH_Instr_Pc_n1;
reg  [31:2] FETCH_Instr_Pc_a0,
            FETCH_Instr_Pc_a1,
            FETCH_Instr_Pc_a2,
            FETCH_Instr_Pc_a3;

// For |fetch/instr$ReachedEnd.
wire FETCH_Instr_ReachedEnd_a2;
reg  FETCH_Instr_ReachedEnd_a3;

// For |fetch/instr$Reg4Became45.
wire FETCH_Instr_Reg4Became45_a2;
reg  FETCH_Instr_Reg4Became45_a3;

// For |fetch/instr$RemainingCyclesWithinTimeUnit.
wire [30-1:0] FETCH_Instr_RemainingCyclesWithinTimeUnit_a1;
reg  [30-1:0] FETCH_Instr_RemainingCyclesWithinTimeUnit_a2;

// For |fetch/instr$abort.
wire FETCH_Instr_abort_a2;

// For |fetch/instr$aborting_isa_trap.
wire FETCH_Instr_aborting_isa_trap_a2;

// For |fetch/instr$aborting_trap.
wire FETCH_Instr_aborting_trap_a2;
reg  FETCH_Instr_aborting_trap_a3;

// For |fetch/instr$add_sub_rslt.
wire [31:0] FETCH_Instr_add_sub_rslt_a2;

// For |fetch/instr$addi_rslt.
wire [31:0] FETCH_Instr_addi_rslt_a2;

// For |fetch/instr$addr.
wire [31:0] FETCH_Instr_addr_a2;
reg  [31:0] FETCH_Instr_addr_a3;

// For |fetch/instr$and_rslt.
wire [31:0] FETCH_Instr_and_rslt_a2;

// For |fetch/instr$andi_rslt.
wire [31:0] FETCH_Instr_andi_rslt_a2;

// For |fetch/instr$auipc_rslt.
wire [31:0] FETCH_Instr_auipc_rslt_a2;

// For |fetch/instr$branch.
wire FETCH_Instr_branch_a1;
reg  FETCH_Instr_branch_a2;

// For |fetch/instr$branch_or_reset.
wire FETCH_Instr_branch_or_reset_a2;
reg  FETCH_Instr_branch_or_reset_a3;

// For |fetch/instr$branch_redir_pc.
wire [31:2] FETCH_Instr_branch_redir_pc_a2;

// For |fetch/instr$branch_target.
wire [31:2] FETCH_Instr_branch_target_a1;
reg  [31:2] FETCH_Instr_branch_target_a2;

// For |fetch/instr$commit.
wire FETCH_Instr_commit_a2;
reg  FETCH_Instr_commit_a3,
     FETCH_Instr_commit_a4,
     FETCH_Instr_commit_a5,
     FETCH_Instr_commit_a6,
     FETCH_Instr_commit_a7,
     FETCH_Instr_commit_a8,
     FETCH_Instr_commit_a9;

// For |fetch/instr$conditional_branch.
wire FETCH_Instr_conditional_branch_a1;
reg  FETCH_Instr_conditional_branch_a2;

// For |fetch/instr$csr_cycle.
wire [31:0] FETCH_Instr_csr_cycle_a1;
reg  [31:0] FETCH_Instr_csr_cycle_a2;

// For |fetch/instr$csr_cycle_hw_wr.
wire FETCH_Instr_csr_cycle_hw_wr_a2;

// For |fetch/instr$csr_cycle_hw_wr_en_mask.
wire [31:0] FETCH_Instr_csr_cycle_hw_wr_en_mask_a2;

// For |fetch/instr$csr_cycle_hw_wr_mask.
wire FETCH_Instr_csr_cycle_hw_wr_mask_a2;

// For |fetch/instr$csr_cycle_hw_wr_value.
wire FETCH_Instr_csr_cycle_hw_wr_value_a2;

// For |fetch/instr$csr_cycle_masked_wr_value.
wire [31:0] FETCH_Instr_csr_cycle_masked_wr_value_a2;

// For |fetch/instr$csr_cycleh.
wire [31:0] FETCH_Instr_csr_cycleh_a1;
reg  [31:0] FETCH_Instr_csr_cycleh_a2;

// For |fetch/instr$csr_cycleh_hw_wr.
wire FETCH_Instr_csr_cycleh_hw_wr_a2;

// For |fetch/instr$csr_cycleh_hw_wr_en_mask.
wire [31:0] FETCH_Instr_csr_cycleh_hw_wr_en_mask_a2;

// For |fetch/instr$csr_cycleh_hw_wr_mask.
wire FETCH_Instr_csr_cycleh_hw_wr_mask_a2;

// For |fetch/instr$csr_cycleh_hw_wr_value.
wire FETCH_Instr_csr_cycleh_hw_wr_value_a2;

// For |fetch/instr$csr_cycleh_masked_wr_value.
wire [31:0] FETCH_Instr_csr_cycleh_masked_wr_value_a2;

// For |fetch/instr$csr_instret.
wire [31:0] FETCH_Instr_csr_instret_a1;
reg  [31:0] FETCH_Instr_csr_instret_a2;

// For |fetch/instr$csr_instret_hw_wr.
wire FETCH_Instr_csr_instret_hw_wr_a2;

// For |fetch/instr$csr_instret_hw_wr_en_mask.
wire [31:0] FETCH_Instr_csr_instret_hw_wr_en_mask_a2;

// For |fetch/instr$csr_instret_hw_wr_mask.
wire FETCH_Instr_csr_instret_hw_wr_mask_a2;

// For |fetch/instr$csr_instret_hw_wr_value.
wire FETCH_Instr_csr_instret_hw_wr_value_a2;

// For |fetch/instr$csr_instret_masked_wr_value.
wire [31:0] FETCH_Instr_csr_instret_masked_wr_value_a2;

// For |fetch/instr$csr_instreth.
wire [31:0] FETCH_Instr_csr_instreth_a1;
reg  [31:0] FETCH_Instr_csr_instreth_a2;

// For |fetch/instr$csr_instreth_hw_wr.
wire FETCH_Instr_csr_instreth_hw_wr_a2;

// For |fetch/instr$csr_instreth_hw_wr_en_mask.
wire [31:0] FETCH_Instr_csr_instreth_hw_wr_en_mask_a2;

// For |fetch/instr$csr_instreth_hw_wr_mask.
wire FETCH_Instr_csr_instreth_hw_wr_mask_a2;

// For |fetch/instr$csr_instreth_hw_wr_value.
wire FETCH_Instr_csr_instreth_hw_wr_value_a2;

// For |fetch/instr$csr_instreth_masked_wr_value.
wire [31:0] FETCH_Instr_csr_instreth_masked_wr_value_a2;

// For |fetch/instr$csr_time.
wire [31:0] FETCH_Instr_csr_time_a1;
reg  [31:0] FETCH_Instr_csr_time_a2;

// For |fetch/instr$csr_time_hw_wr.
wire FETCH_Instr_csr_time_hw_wr_a2;

// For |fetch/instr$csr_time_hw_wr_en_mask.
wire [31:0] FETCH_Instr_csr_time_hw_wr_en_mask_a2;

// For |fetch/instr$csr_time_hw_wr_mask.
wire FETCH_Instr_csr_time_hw_wr_mask_a2;

// For |fetch/instr$csr_time_hw_wr_value.
wire FETCH_Instr_csr_time_hw_wr_value_a2;

// For |fetch/instr$csr_time_masked_wr_value.
wire [31:0] FETCH_Instr_csr_time_masked_wr_value_a2;

// For |fetch/instr$csr_timeh.
wire [31:0] FETCH_Instr_csr_timeh_a1;
reg  [31:0] FETCH_Instr_csr_timeh_a2;

// For |fetch/instr$csr_timeh_hw_wr.
wire FETCH_Instr_csr_timeh_hw_wr_a2;

// For |fetch/instr$csr_timeh_hw_wr_en_mask.
wire [31:0] FETCH_Instr_csr_timeh_hw_wr_en_mask_a2;

// For |fetch/instr$csr_timeh_hw_wr_mask.
wire FETCH_Instr_csr_timeh_hw_wr_mask_a2;

// For |fetch/instr$csr_timeh_hw_wr_value.
wire FETCH_Instr_csr_timeh_hw_wr_value_a2;

// For |fetch/instr$csr_timeh_masked_wr_value.
wire [31:0] FETCH_Instr_csr_timeh_masked_wr_value_a2;

// For |fetch/instr$csr_trap.
wire FETCH_Instr_csr_trap_a2;

// For |fetch/instr$csrrc_rslt.
wire [31:0] FETCH_Instr_csrrc_rslt_a2;

// For |fetch/instr$csrrci_rslt.
wire [31:0] FETCH_Instr_csrrci_rslt_a2;

// For |fetch/instr$csrrs_rslt.
wire [31:0] FETCH_Instr_csrrs_rslt_a2;

// For |fetch/instr$csrrsi_rslt.
wire [31:0] FETCH_Instr_csrrsi_rslt_a2;

// For |fetch/instr$csrrw_rslt.
wire [31:0] FETCH_Instr_csrrw_rslt_a2;

// For |fetch/instr$csrrwi_rslt.
wire [31:0] FETCH_Instr_csrrwi_rslt_a2;

// For |fetch/instr$dest_pending.
wire FETCH_Instr_dest_pending_a1;

// For |fetch/instr$dest_reg.
wire [4:0] FETCH_Instr_dest_reg_a1;
reg  [4:0] FETCH_Instr_dest_reg_a2,
           FETCH_Instr_dest_reg_a3;

// For |fetch/instr$dest_reg_valid.
wire FETCH_Instr_dest_reg_valid_a1;
reg  FETCH_Instr_dest_reg_valid_a2,
     FETCH_Instr_dest_reg_valid_a3;

// For |fetch/instr$equal.
wire FETCH_Instr_equal_a2;

// For |fetch/instr$fetch.
wire FETCH_Instr_fetch_a0;
reg  FETCH_Instr_fetch_a1;

// For |fetch/instr$full_csr_cycle_hw_wr_value.
wire [63:0] FETCH_Instr_full_csr_cycle_hw_wr_value_a2;

// For |fetch/instr$full_csr_instret_hw_wr_value.
wire [63:0] FETCH_Instr_full_csr_instret_hw_wr_value_a2;

// For |fetch/instr$full_csr_time_hw_wr_value.
wire [63:0] FETCH_Instr_full_csr_time_hw_wr_value_a2;

// For |fetch/instr$illegal.
wire FETCH_Instr_illegal_a1;
reg  FETCH_Instr_illegal_a2,
     FETCH_Instr_illegal_a3,
     FETCH_Instr_illegal_a4,
     FETCH_Instr_illegal_a5,
     FETCH_Instr_illegal_a6,
     FETCH_Instr_illegal_a7,
     FETCH_Instr_illegal_a8,
     FETCH_Instr_illegal_a9;

// For |fetch/instr$indirect_jump.
wire FETCH_Instr_indirect_jump_a1;
reg  FETCH_Instr_indirect_jump_a2;

// For |fetch/instr$indirect_jump_full_target.
wire [31:0] FETCH_Instr_indirect_jump_full_target_a2;

// For |fetch/instr$indirect_jump_target.
wire [31:2] FETCH_Instr_indirect_jump_target_a2;

// For |fetch/instr$is___type.
wire FETCH_Instr_is___type_a1;

// For |fetch/instr$is_add_sub_instr.
wire FETCH_Instr_is_add_sub_instr_a1;
reg  FETCH_Instr_is_add_sub_instr_a2;

// For |fetch/instr$is_addi_instr.
wire FETCH_Instr_is_addi_instr_a1;
reg  FETCH_Instr_is_addi_instr_a2;

// For |fetch/instr$is_and_instr.
wire FETCH_Instr_is_and_instr_a1;
reg  FETCH_Instr_is_and_instr_a2;

// For |fetch/instr$is_andi_instr.
wire FETCH_Instr_is_andi_instr_a1;
reg  FETCH_Instr_is_andi_instr_a2;

// For |fetch/instr$is_auipc_instr.
wire FETCH_Instr_is_auipc_instr_a1;
reg  FETCH_Instr_is_auipc_instr_a2;

// For |fetch/instr$is_b_type.
wire FETCH_Instr_is_b_type_a1;

// For |fetch/instr$is_beq_instr.
wire FETCH_Instr_is_beq_instr_a1;
reg  FETCH_Instr_is_beq_instr_a2;

// For |fetch/instr$is_bge_instr.
wire FETCH_Instr_is_bge_instr_a1;
reg  FETCH_Instr_is_bge_instr_a2;

// For |fetch/instr$is_bgeu_instr.
wire FETCH_Instr_is_bgeu_instr_a1;
reg  FETCH_Instr_is_bgeu_instr_a2;

// For |fetch/instr$is_blt_instr.
wire FETCH_Instr_is_blt_instr_a1;
reg  FETCH_Instr_is_blt_instr_a2;

// For |fetch/instr$is_bltu_instr.
wire FETCH_Instr_is_bltu_instr_a1;
reg  FETCH_Instr_is_bltu_instr_a2;

// For |fetch/instr$is_bne_instr.
wire FETCH_Instr_is_bne_instr_a1;
reg  FETCH_Instr_is_bne_instr_a2;

// For |fetch/instr$is_csr_cycle.
wire FETCH_Instr_is_csr_cycle_a1;
reg  FETCH_Instr_is_csr_cycle_a2;

// For |fetch/instr$is_csr_cycleh.
wire FETCH_Instr_is_csr_cycleh_a1;
reg  FETCH_Instr_is_csr_cycleh_a2;

// For |fetch/instr$is_csr_instr.
wire FETCH_Instr_is_csr_instr_a2;

// For |fetch/instr$is_csr_instret.
wire FETCH_Instr_is_csr_instret_a1;
reg  FETCH_Instr_is_csr_instret_a2;

// For |fetch/instr$is_csr_instreth.
wire FETCH_Instr_is_csr_instreth_a1;
reg  FETCH_Instr_is_csr_instreth_a2;

// For |fetch/instr$is_csr_time.
wire FETCH_Instr_is_csr_time_a1;
reg  FETCH_Instr_is_csr_time_a2;

// For |fetch/instr$is_csr_timeh.
wire FETCH_Instr_is_csr_timeh_a1;
reg  FETCH_Instr_is_csr_timeh_a2;

// For |fetch/instr$is_csrrc_instr.
wire FETCH_Instr_is_csrrc_instr_a1;
reg  FETCH_Instr_is_csrrc_instr_a2;

// For |fetch/instr$is_csrrci_instr.
wire FETCH_Instr_is_csrrci_instr_a1;
reg  FETCH_Instr_is_csrrci_instr_a2;

// For |fetch/instr$is_csrrs_instr.
wire FETCH_Instr_is_csrrs_instr_a1;
reg  FETCH_Instr_is_csrrs_instr_a2;

// For |fetch/instr$is_csrrsi_instr.
wire FETCH_Instr_is_csrrsi_instr_a1;
reg  FETCH_Instr_is_csrrsi_instr_a2;

// For |fetch/instr$is_csrrw_instr.
wire FETCH_Instr_is_csrrw_instr_a1;
reg  FETCH_Instr_is_csrrw_instr_a2;

// For |fetch/instr$is_csrrwi_instr.
wire FETCH_Instr_is_csrrwi_instr_a1;
reg  FETCH_Instr_is_csrrwi_instr_a2;

// For |fetch/instr$is_dest_condition.
wire FETCH_Instr_is_dest_condition_a1;

// For |fetch/instr$is_i_type.
wire FETCH_Instr_is_i_type_a1;

// For |fetch/instr$is_j_type.
wire FETCH_Instr_is_j_type_a1;
reg  FETCH_Instr_is_j_type_a2;

// For |fetch/instr$is_jal_instr.
wire FETCH_Instr_is_jal_instr_a1;
reg  FETCH_Instr_is_jal_instr_a2;

// For |fetch/instr$is_jalr_instr.
wire FETCH_Instr_is_jalr_instr_a1;
reg  FETCH_Instr_is_jalr_instr_a2;

// For |fetch/instr$is_lb_instr.
wire FETCH_Instr_is_lb_instr_a1;
reg  FETCH_Instr_is_lb_instr_a2;

// For |fetch/instr$is_lbu_instr.
wire FETCH_Instr_is_lbu_instr_a1;
reg  FETCH_Instr_is_lbu_instr_a2;

// For |fetch/instr$is_lh_instr.
wire FETCH_Instr_is_lh_instr_a1;
reg  FETCH_Instr_is_lh_instr_a2;

// For |fetch/instr$is_lhu_instr.
wire FETCH_Instr_is_lhu_instr_a1;
reg  FETCH_Instr_is_lhu_instr_a2;

// For |fetch/instr$is_lui_instr.
wire FETCH_Instr_is_lui_instr_a1;
reg  FETCH_Instr_is_lui_instr_a2;

// For |fetch/instr$is_lw_instr.
wire FETCH_Instr_is_lw_instr_a1;
reg  FETCH_Instr_is_lw_instr_a2;

// For |fetch/instr$is_or_instr.
wire FETCH_Instr_is_or_instr_a1;
reg  FETCH_Instr_is_or_instr_a2;

// For |fetch/instr$is_ori_instr.
wire FETCH_Instr_is_ori_instr_a1;
reg  FETCH_Instr_is_ori_instr_a2;

// For |fetch/instr$is_r4_type.
wire FETCH_Instr_is_r4_type_a1;

// For |fetch/instr$is_r_type.
wire FETCH_Instr_is_r_type_a1;

// For |fetch/instr$is_ri_type.
wire FETCH_Instr_is_ri_type_a1;

// For |fetch/instr$is_s_type.
wire FETCH_Instr_is_s_type_a1;

// For |fetch/instr$is_sb_instr.
wire FETCH_Instr_is_sb_instr_a1;

// For |fetch/instr$is_sh_instr.
wire FETCH_Instr_is_sh_instr_a1;

// For |fetch/instr$is_sll_instr.
wire FETCH_Instr_is_sll_instr_a1;
reg  FETCH_Instr_is_sll_instr_a2;

// For |fetch/instr$is_slli_instr.
wire FETCH_Instr_is_slli_instr_a1;
reg  FETCH_Instr_is_slli_instr_a2;

// For |fetch/instr$is_slt_instr.
wire FETCH_Instr_is_slt_instr_a1;
reg  FETCH_Instr_is_slt_instr_a2;

// For |fetch/instr$is_slti_instr.
wire FETCH_Instr_is_slti_instr_a1;
reg  FETCH_Instr_is_slti_instr_a2;

// For |fetch/instr$is_sltiu_instr.
wire FETCH_Instr_is_sltiu_instr_a1;
reg  FETCH_Instr_is_sltiu_instr_a2;

// For |fetch/instr$is_sltu_instr.
wire FETCH_Instr_is_sltu_instr_a1;
reg  FETCH_Instr_is_sltu_instr_a2;

// For |fetch/instr$is_srl_sra_instr.
wire FETCH_Instr_is_srl_sra_instr_a1;
reg  FETCH_Instr_is_srl_sra_instr_a2;

// For |fetch/instr$is_srli_srai_instr.
wire FETCH_Instr_is_srli_srai_instr_a1;
reg  FETCH_Instr_is_srli_srai_instr_a2;

// For |fetch/instr$is_sw_instr.
wire FETCH_Instr_is_sw_instr_a1;

// For |fetch/instr$is_u_type.
wire FETCH_Instr_is_u_type_a1;

// For |fetch/instr$is_xor_instr.
wire FETCH_Instr_is_xor_instr_a1;
reg  FETCH_Instr_is_xor_instr_a2;

// For |fetch/instr$is_xori_instr.
wire FETCH_Instr_is_xori_instr_a1;
reg  FETCH_Instr_is_xori_instr_a2;

// For |fetch/instr$jal_rslt.
wire [31:0] FETCH_Instr_jal_rslt_a2;

// For |fetch/instr$jalr_rslt.
wire [31:0] FETCH_Instr_jalr_rslt_a2;

// For |fetch/instr$jump.
wire FETCH_Instr_jump_a1;
reg  FETCH_Instr_jump_a2;

// For |fetch/instr$jump_target.
wire [31:2] FETCH_Instr_jump_target_a1;
reg  [31:2] FETCH_Instr_jump_target_a2;

// For |fetch/instr$lb_rslt.
wire [31:0] FETCH_Instr_lb_rslt_a2;

// For |fetch/instr$lbu_rslt.
wire [31:0] FETCH_Instr_lbu_rslt_a2;

// For |fetch/instr$ld.
wire FETCH_Instr_ld_a1;
reg  FETCH_Instr_ld_a2;

// For |fetch/instr$ld_st.
wire FETCH_Instr_ld_st_a1;
reg  FETCH_Instr_ld_st_a2;

// For |fetch/instr$ld_st_cond.
wire FETCH_Instr_ld_st_cond_a2;

// For |fetch/instr$ld_st_half.
wire FETCH_Instr_ld_st_half_a1;
reg  FETCH_Instr_ld_st_half_a2,
     FETCH_Instr_ld_st_half_a3;

// For |fetch/instr$ld_st_word.
wire FETCH_Instr_ld_st_word_a1;
reg  FETCH_Instr_ld_st_word_a2,
     FETCH_Instr_ld_st_word_a3;

// For |fetch/instr$ld_value.
wire [31:0] FETCH_Instr_ld_value_a3;

// For |fetch/instr$lh_rslt.
wire [31:0] FETCH_Instr_lh_rslt_a2;

// For |fetch/instr$lhu_rslt.
wire [31:0] FETCH_Instr_lhu_rslt_a2;

// For |fetch/instr$lui_rslt.
wire [31:0] FETCH_Instr_lui_rslt_a2;

// For |fetch/instr$lw_rslt.
wire [31:0] FETCH_Instr_lw_rslt_a2;

// For |fetch/instr$masked_csr_wr_value.
wire [31:0] FETCH_Instr_masked_csr_wr_value_a2;

// For |fetch/instr$misaligned_indirect_jump_target.
wire FETCH_Instr_misaligned_indirect_jump_target_a2;

// For |fetch/instr$misaligned_jump_target.
wire FETCH_Instr_misaligned_jump_target_a1;
reg  FETCH_Instr_misaligned_jump_target_a2;

// For |fetch/instr$misaligned_pc.
wire FETCH_Instr_misaligned_pc_a1;
reg  FETCH_Instr_misaligned_pc_a2;

// For |fetch/instr$mispred_branch.
wire FETCH_Instr_mispred_branch_a2;

// For |fetch/instr$mnemonic.
wire [10*8-1:0] FETCH_Instr_mnemonic_a1;

// For |fetch/instr$next_good_path_mask.
wire [3+1:0] FETCH_Instr_next_good_path_mask_a0;

// For |fetch/instr$non_aborting_isa_trap.
wire FETCH_Instr_non_aborting_isa_trap_a2;

// For |fetch/instr$non_aborting_trap.
wire FETCH_Instr_non_aborting_trap_a2;
reg  FETCH_Instr_non_aborting_trap_a3;

// For |fetch/instr$or_rslt.
wire [31:0] FETCH_Instr_or_rslt_a2;

// For |fetch/instr$ori_rslt.
wire [31:0] FETCH_Instr_ori_rslt_a2;

// For |fetch/instr$pred_taken.
wire FETCH_Instr_pred_taken_a1;
reg  FETCH_Instr_pred_taken_a2;

// For |fetch/instr$pred_taken_branch.
wire FETCH_Instr_pred_taken_branch_a1;

// For |fetch/instr$raw.
wire [31:0] FETCH_Instr_raw_a0;
reg  [31:0] FETCH_Instr_raw_a1;

// For |fetch/instr$raw_aq.
wire FETCH_Instr_raw_aq_a1;

// For |fetch/instr$raw_b_imm.
wire [31:0] FETCH_Instr_raw_b_imm_a1;

// For |fetch/instr$raw_funct3.
wire [2:0] FETCH_Instr_raw_funct3_a1;
reg  [2:2] FETCH_Instr_raw_funct3_a2,
           FETCH_Instr_raw_funct3_a3;

// For |fetch/instr$raw_funct7.
wire [6:0] FETCH_Instr_raw_funct7_a1;
reg  [5:5] FETCH_Instr_raw_funct7_a2;

// For |fetch/instr$raw_i_imm.
wire [31:0] FETCH_Instr_raw_i_imm_a1;
reg  [31:0] FETCH_Instr_raw_i_imm_a2;

// For |fetch/instr$raw_j_imm.
wire [31:0] FETCH_Instr_raw_j_imm_a1;

// For |fetch/instr$raw_op2.
wire [1:0] FETCH_Instr_raw_op2_a1;

// For |fetch/instr$raw_op5.
wire [4:0] FETCH_Instr_raw_op5_a1;

// For |fetch/instr$raw_rd.
wire [4:0] FETCH_Instr_raw_rd_a1;

// For |fetch/instr$raw_rl.
wire FETCH_Instr_raw_rl_a1;

// For |fetch/instr$raw_rm.
wire [2:0] FETCH_Instr_raw_rm_a1;

// For |fetch/instr$raw_rs1.
wire [4:0] FETCH_Instr_raw_rs1_a1;
reg  [4:0] FETCH_Instr_raw_rs1_a2;

// For |fetch/instr$raw_rs2.
wire [4:0] FETCH_Instr_raw_rs2_a1;

// For |fetch/instr$raw_rs3.
wire [4:0] FETCH_Instr_raw_rs3_a1;

// For |fetch/instr$raw_s_imm.
wire [31:0] FETCH_Instr_raw_s_imm_a1;
reg  [31:0] FETCH_Instr_raw_s_imm_a2;

// For |fetch/instr$raw_shamt.
wire [6:0] FETCH_Instr_raw_shamt_a1;

// For |fetch/instr$raw_u_imm.
wire [31:0] FETCH_Instr_raw_u_imm_a1;
reg  [31:0] FETCH_Instr_raw_u_imm_a2;

// For |fetch/instr$reg_wr_pending.
wire FETCH_Instr_reg_wr_pending_a1;
reg  FETCH_Instr_reg_wr_pending_a2,
     FETCH_Instr_reg_wr_pending_a3;

// For |fetch/instr$reg_write.
wire FETCH_Instr_reg_write_a3;

// For |fetch/instr$replay.
wire FETCH_Instr_replay_a1;
reg  FETCH_Instr_replay_a2,
     FETCH_Instr_replay_a3;

// For |fetch/instr$reset.
wire FETCH_Instr_reset_n1;
reg  FETCH_Instr_reset_a0,
     FETCH_Instr_reset_a1,
     FETCH_Instr_reset_a2,
     FETCH_Instr_reset_a3,
     FETCH_Instr_reset_a4,
     FETCH_Instr_reset_a5,
     FETCH_Instr_reset_a6;

// For |fetch/instr$returning_ld.
wire FETCH_Instr_returning_ld_a0;
reg  FETCH_Instr_returning_ld_a1,
     FETCH_Instr_returning_ld_a2,
     FETCH_Instr_returning_ld_a3;

// For |fetch/instr$rslt.
wire [31:0] FETCH_Instr_rslt_a2;
reg  [31:0] FETCH_Instr_rslt_a3;

// For |fetch/instr$sll_rslt.
wire [31:0] FETCH_Instr_sll_rslt_a2;

// For |fetch/instr$slli_rslt.
wire [31:0] FETCH_Instr_slli_rslt_a2;

// For |fetch/instr$slt_rslt.
wire [31:0] FETCH_Instr_slt_rslt_a2;

// For |fetch/instr$slti_rslt.
wire [31:0] FETCH_Instr_slti_rslt_a2;

// For |fetch/instr$sltiu_rslt.
wire [31:0] FETCH_Instr_sltiu_rslt_a2;

// For |fetch/instr$sltu_rslt.
wire [31:0] FETCH_Instr_sltu_rslt_a2;

// For |fetch/instr$spec_ld.
wire FETCH_Instr_spec_ld_a1;
reg  FETCH_Instr_spec_ld_a2,
     FETCH_Instr_spec_ld_a3;

// For |fetch/instr$sra_intermediate_rslt.
wire [31:0] FETCH_Instr_sra_intermediate_rslt_a2;

// For |fetch/instr$srai_intermediate_rslt.
wire [31:0] FETCH_Instr_srai_intermediate_rslt_a2;

// For |fetch/instr$srl_intermediate_rslt.
wire [31:0] FETCH_Instr_srl_intermediate_rslt_a2;

// For |fetch/instr$srl_sra_rslt.
wire [31:0] FETCH_Instr_srl_sra_rslt_a2;

// For |fetch/instr$srli_intermediate_rslt.
wire [31:0] FETCH_Instr_srli_intermediate_rslt_a2;

// For |fetch/instr$srli_srai_rslt.
wire [31:0] FETCH_Instr_srli_srai_rslt_a2;

// For |fetch/instr$st.
wire FETCH_Instr_st_a1;
reg  FETCH_Instr_st_a2;

// For |fetch/instr$st_cond.
wire FETCH_Instr_st_cond_a2;

// For |fetch/instr$st_mask.
wire [3:0] FETCH_Instr_st_mask_a2;
reg  [3:0] FETCH_Instr_st_mask_a3;

// For |fetch/instr$st_reg_value.
wire [31:0] FETCH_Instr_st_reg_value_a2;

// For |fetch/instr$st_value.
wire [31:0] FETCH_Instr_st_value_a2;
reg  [31:0] FETCH_Instr_st_value_a3;

// For |fetch/instr$taken.
wire FETCH_Instr_taken_a2;

// For |fetch/instr$time_unit_expires.
wire FETCH_Instr_time_unit_expires_a2;

// For |fetch/instr$trap_target.
wire [31:2] FETCH_Instr_trap_target_a2;
reg  [31:2] FETCH_Instr_trap_target_a3;

// For |fetch/instr$unnatural_addr_trap.
wire FETCH_Instr_unnatural_addr_trap_a2;

// For |fetch/instr$upd_csr_cycle.
wire [31:0] FETCH_Instr_upd_csr_cycle_a2;

// For |fetch/instr$upd_csr_cycleh.
wire [31:0] FETCH_Instr_upd_csr_cycleh_a2;

// For |fetch/instr$upd_csr_instret.
wire [31:0] FETCH_Instr_upd_csr_instret_a2;

// For |fetch/instr$upd_csr_instreth.
wire [31:0] FETCH_Instr_upd_csr_instreth_a2;

// For |fetch/instr$upd_csr_time.
wire [31:0] FETCH_Instr_upd_csr_time_a2;

// For |fetch/instr$upd_csr_timeh.
wire [31:0] FETCH_Instr_upd_csr_timeh_a2;

// For |fetch/instr$valid_csr.
wire FETCH_Instr_valid_csr_a2;

// For |fetch/instr$valid_decode.
wire FETCH_Instr_valid_decode_a1;
reg  FETCH_Instr_valid_decode_a2,
     FETCH_Instr_valid_decode_a3,
     FETCH_Instr_valid_decode_a4,
     FETCH_Instr_valid_decode_a5,
     FETCH_Instr_valid_decode_a6,
     FETCH_Instr_valid_decode_a7,
     FETCH_Instr_valid_decode_a8;

// For |fetch/instr$valid_decode_branch.
wire FETCH_Instr_valid_decode_branch_a1;
reg  FETCH_Instr_valid_decode_branch_a2;

// For |fetch/instr$valid_dest_reg_valid.
wire FETCH_Instr_valid_dest_reg_valid_a2;
reg  FETCH_Instr_valid_dest_reg_valid_a3;

// For |fetch/instr$valid_exe.
wire FETCH_Instr_valid_exe_a2;

// For |fetch/instr$valid_ld.
wire FETCH_Instr_valid_ld_a2;
reg  FETCH_Instr_valid_ld_a3;

// For |fetch/instr$valid_st.
wire FETCH_Instr_valid_st_a2;
reg  FETCH_Instr_valid_st_a3;

// For |fetch/instr$xor_rslt.
wire [31:0] FETCH_Instr_xor_rslt_a2;

// For |fetch/instr$xori_rslt.
wire [31:0] FETCH_Instr_xori_rslt_a2;

// For |fetch/instr/original_ld$addr.
wire [1:0] FETCH_Instr_OriginalLd_addr_a0;
reg  [1:0] FETCH_Instr_OriginalLd_addr_a1,
           FETCH_Instr_OriginalLd_addr_a2;

// For |fetch/instr/original_ld$dest_reg.
wire [4:0] FETCH_Instr_OriginalLd_dest_reg_a0;
reg  [4:0] FETCH_Instr_OriginalLd_dest_reg_a1;

// For |fetch/instr/original_ld$ld_mask.
wire [3:0] FETCH_Instr_OriginalLd_ld_mask_a2;

// For |fetch/instr/original_ld$ld_rslt.
wire [31:0] FETCH_Instr_OriginalLd_ld_rslt_a2;

// For |fetch/instr/original_ld$ld_st_half.
wire FETCH_Instr_OriginalLd_ld_st_half_a0;
reg  FETCH_Instr_OriginalLd_ld_st_half_a1,
     FETCH_Instr_OriginalLd_ld_st_half_a2;

// For |fetch/instr/original_ld$ld_st_word.
wire FETCH_Instr_OriginalLd_ld_st_word_a0;
reg  FETCH_Instr_OriginalLd_ld_st_word_a1,
     FETCH_Instr_OriginalLd_ld_st_word_a2;

// For |fetch/instr/original_ld$ld_value.
wire [31:0] FETCH_Instr_OriginalLd_ld_value_a0;
reg  [31:0] FETCH_Instr_OriginalLd_ld_value_a1,
            FETCH_Instr_OriginalLd_ld_value_a2;

// For |fetch/instr/original_ld$raw_funct3.
wire [2:2] FETCH_Instr_OriginalLd_raw_funct3_a0;
reg  [2:2] FETCH_Instr_OriginalLd_raw_funct3_a1,
           FETCH_Instr_OriginalLd_raw_funct3_a2;

// For |fetch/instr/original_ld$sign_bit.
wire FETCH_Instr_OriginalLd_sign_bit_a2;

// For |fetch/instr/regs$pending.
wire FETCH_Instr_Regs_pending_a2 [31:1];
reg  FETCH_Instr_Regs_pending_a3 [31:1];

// For |fetch/instr/regs$value.
wire [31:0] FETCH_Instr_Regs_value_a3 [31:1];

// For |fetch/instr/src$replay.
wire [2:1] FETCH_Instr_Src_replay_a1;

// For |mem/data$addr.
wire [1:0] MEM_Data_addr_a3;
reg  [1:0] MEM_Data_addr_a4;

// For |mem/data$dest_reg.
wire [4:0] MEM_Data_dest_reg_a3;
reg  [4:0] MEM_Data_dest_reg_a4;

// For |mem/data$ld_st_half.
wire MEM_Data_ld_st_half_a3;
reg  MEM_Data_ld_st_half_a4;

// For |mem/data$ld_st_word.
wire MEM_Data_ld_st_word_a3;
reg  MEM_Data_ld_st_word_a4;

// For |mem/data$ld_value.
wire [31:0] MEM_Data_ld_value_a3;
reg  [31:0] MEM_Data_ld_value_a4;

// For |mem/data$raw_funct3.
wire [2:2] MEM_Data_raw_funct3_a3;
reg  [2:2] MEM_Data_raw_funct3_a4;

// For |mem/data$valid_ld.
wire MEM_Data_valid_ld_a3;
reg  MEM_Data_valid_ld_a4;


//
// Scope: |fetch
//

//
// Scope: |fetch/instr
//

// Clock signals.
wire clkF_FETCH_Instr_branch_or_reset_a3 ;
wire clkF_FETCH_Instr_branch_or_reset_a4 ;
wire clkP_FETCH_Instr_branch_a2 ;
wire clkP_FETCH_Instr_fetch_a1 ;
wire clkP_FETCH_Instr_jump_a2 ;
wire clkP_FETCH_Instr_ld_st_cond_a3 ;
wire clkP_FETCH_Instr_returning_ld_a1 ;
wire clkP_FETCH_Instr_returning_ld_a2 ;
wire clkP_FETCH_Instr_returning_ld_a3 ;
wire clkP_FETCH_Instr_st_cond_a3 ;
wire clkP_FETCH_Instr_valid_decode_a2 ;
wire clkP_FETCH_Instr_valid_decode_a3 ;
wire clkP_FETCH_Instr_valid_decode_a4 ;
wire clkP_FETCH_Instr_valid_decode_a5 ;
wire clkP_FETCH_Instr_valid_decode_a6 ;
wire clkP_FETCH_Instr_valid_decode_a7 ;
wire clkP_FETCH_Instr_valid_decode_a8 ;
wire clkP_FETCH_Instr_valid_decode_a9 ;
wire clkP_FETCH_Instr_valid_decode_branch_a2 ;

//
// Scope: |fetch/instr/src[2:1]
//

// Clock signals.
wire clkP_FETCH_Instr_Src_is_reg_condition_a2 [2:1];


generate


   //
   // Scope: |fetch
   //


      //
      // Scope: /instr
      //

         // For $BranchState.
         always @(posedge clkF_FETCH_Instr_branch_or_reset_a3) FETCH_Instr_BranchState_a2[1:0] <= FETCH_Instr_BranchState_a1[1:0];
         always @(posedge clkF_FETCH_Instr_branch_or_reset_a4) FETCH_Instr_BranchState_a3[1] <= FETCH_Instr_BranchState_a2[1];

         // For $Cnt.
         always @(posedge clk) FETCH_Instr_Cnt_n1[7:0] <= FETCH_Instr_Cnt_n2[7:0];

         // For $GoodPathMask.
         always @(posedge clk) FETCH_Instr_GoodPathMask_a0[3+1:0] <= FETCH_Instr_GoodPathMask_n1[3+1:0];
         always @(posedge clk) FETCH_Instr_GoodPathMask_a1[3+1:1] <= FETCH_Instr_GoodPathMask_a0[3+1:1];

         // For $Pc.
         always @(posedge clk) FETCH_Instr_Pc_a0[31:2] <= FETCH_Instr_Pc_n1[31:2];
         always @(posedge clk) FETCH_Instr_Pc_a1[31:2] <= FETCH_Instr_Pc_a0[31:2];
         always @(posedge clk) FETCH_Instr_Pc_a2[31:2] <= FETCH_Instr_Pc_a1[31:2];
         always @(posedge clk) FETCH_Instr_Pc_a3[31:2] <= FETCH_Instr_Pc_a2[31:2];

         // For $ReachedEnd.
         always @(posedge clk) FETCH_Instr_ReachedEnd_a3 <= FETCH_Instr_ReachedEnd_a2;

         // For $Reg4Became45.
         always @(posedge clk) FETCH_Instr_Reg4Became45_a3 <= FETCH_Instr_Reg4Became45_a2;

         // For $RemainingCyclesWithinTimeUnit.
         always @(posedge clk) FETCH_Instr_RemainingCyclesWithinTimeUnit_a2[30-1:0] <= FETCH_Instr_RemainingCyclesWithinTimeUnit_a1[30-1:0];

         // For $aborting_trap.
         always @(posedge clk) FETCH_Instr_aborting_trap_a3 <= FETCH_Instr_aborting_trap_a2;

         // For $addr.
         always @(posedge clkP_FETCH_Instr_ld_st_cond_a3) FETCH_Instr_addr_a3[31:0] <= FETCH_Instr_addr_a2[31:0];

         // For $branch.
         always @(posedge clk) FETCH_Instr_branch_a2 <= FETCH_Instr_branch_a1;

         // For $branch_or_reset.
         always @(posedge clk) FETCH_Instr_branch_or_reset_a3 <= FETCH_Instr_branch_or_reset_a2;

         // For $branch_target.
         always @(posedge clkP_FETCH_Instr_valid_decode_branch_a2) FETCH_Instr_branch_target_a2[31:2] <= FETCH_Instr_branch_target_a1[31:2];

         // For $commit.
         always @(posedge clk) FETCH_Instr_commit_a3 <= FETCH_Instr_commit_a2;
         always @(posedge clk) FETCH_Instr_commit_a4 <= FETCH_Instr_commit_a3;
         always @(posedge clk) FETCH_Instr_commit_a5 <= FETCH_Instr_commit_a4;
         always @(posedge clk) FETCH_Instr_commit_a6 <= FETCH_Instr_commit_a5;
         always @(posedge clk) FETCH_Instr_commit_a7 <= FETCH_Instr_commit_a6;
         always @(posedge clk) FETCH_Instr_commit_a8 <= FETCH_Instr_commit_a7;
         always @(posedge clk) FETCH_Instr_commit_a9 <= FETCH_Instr_commit_a8;

         // For $conditional_branch.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_conditional_branch_a2 <= FETCH_Instr_conditional_branch_a1;

         // For $csr_cycle.
         always @(posedge clk) FETCH_Instr_csr_cycle_a2[31:0] <= FETCH_Instr_csr_cycle_a1[31:0];

         // For $csr_cycleh.
         always @(posedge clk) FETCH_Instr_csr_cycleh_a2[31:0] <= FETCH_Instr_csr_cycleh_a1[31:0];

         // For $csr_instret.
         always @(posedge clk) FETCH_Instr_csr_instret_a2[31:0] <= FETCH_Instr_csr_instret_a1[31:0];

         // For $csr_instreth.
         always @(posedge clk) FETCH_Instr_csr_instreth_a2[31:0] <= FETCH_Instr_csr_instreth_a1[31:0];

         // For $csr_time.
         always @(posedge clk) FETCH_Instr_csr_time_a2[31:0] <= FETCH_Instr_csr_time_a1[31:0];

         // For $csr_timeh.
         always @(posedge clk) FETCH_Instr_csr_timeh_a2[31:0] <= FETCH_Instr_csr_timeh_a1[31:0];

         // For $dest_reg.
         always @(posedge clk) FETCH_Instr_dest_reg_a2[4:0] <= FETCH_Instr_dest_reg_a1[4:0];
         always @(posedge clk) FETCH_Instr_dest_reg_a3[4:0] <= FETCH_Instr_dest_reg_a2[4:0];

         // For $dest_reg_valid.
         always @(posedge clk) FETCH_Instr_dest_reg_valid_a2 <= FETCH_Instr_dest_reg_valid_a1;
         always @(posedge clk) FETCH_Instr_dest_reg_valid_a3 <= FETCH_Instr_dest_reg_valid_a2;

         // For $fetch.
         always @(posedge clk) FETCH_Instr_fetch_a1 <= FETCH_Instr_fetch_a0;

         // For $illegal.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_illegal_a2 <= FETCH_Instr_illegal_a1;
         always @(posedge clkP_FETCH_Instr_valid_decode_a3) FETCH_Instr_illegal_a3 <= FETCH_Instr_illegal_a2;
         always @(posedge clkP_FETCH_Instr_valid_decode_a4) FETCH_Instr_illegal_a4 <= FETCH_Instr_illegal_a3;
         always @(posedge clkP_FETCH_Instr_valid_decode_a5) FETCH_Instr_illegal_a5 <= FETCH_Instr_illegal_a4;
         always @(posedge clkP_FETCH_Instr_valid_decode_a6) FETCH_Instr_illegal_a6 <= FETCH_Instr_illegal_a5;
         always @(posedge clkP_FETCH_Instr_valid_decode_a7) FETCH_Instr_illegal_a7 <= FETCH_Instr_illegal_a6;
         always @(posedge clkP_FETCH_Instr_valid_decode_a8) FETCH_Instr_illegal_a8 <= FETCH_Instr_illegal_a7;
         always @(posedge clkP_FETCH_Instr_valid_decode_a9) FETCH_Instr_illegal_a9 <= FETCH_Instr_illegal_a8;

         // For $indirect_jump.
         always @(posedge clk) FETCH_Instr_indirect_jump_a2 <= FETCH_Instr_indirect_jump_a1;

         // For $is_add_sub_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_add_sub_instr_a2 <= FETCH_Instr_is_add_sub_instr_a1;

         // For $is_addi_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_addi_instr_a2 <= FETCH_Instr_is_addi_instr_a1;

         // For $is_and_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_and_instr_a2 <= FETCH_Instr_is_and_instr_a1;

         // For $is_andi_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_andi_instr_a2 <= FETCH_Instr_is_andi_instr_a1;

         // For $is_auipc_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_auipc_instr_a2 <= FETCH_Instr_is_auipc_instr_a1;

         // For $is_beq_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_beq_instr_a2 <= FETCH_Instr_is_beq_instr_a1;

         // For $is_bge_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_bge_instr_a2 <= FETCH_Instr_is_bge_instr_a1;

         // For $is_bgeu_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_bgeu_instr_a2 <= FETCH_Instr_is_bgeu_instr_a1;

         // For $is_blt_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_blt_instr_a2 <= FETCH_Instr_is_blt_instr_a1;

         // For $is_bltu_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_bltu_instr_a2 <= FETCH_Instr_is_bltu_instr_a1;

         // For $is_bne_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_bne_instr_a2 <= FETCH_Instr_is_bne_instr_a1;

         // For $is_csr_cycle.
         always @(posedge clk) FETCH_Instr_is_csr_cycle_a2 <= FETCH_Instr_is_csr_cycle_a1;

         // For $is_csr_cycleh.
         always @(posedge clk) FETCH_Instr_is_csr_cycleh_a2 <= FETCH_Instr_is_csr_cycleh_a1;

         // For $is_csr_instret.
         always @(posedge clk) FETCH_Instr_is_csr_instret_a2 <= FETCH_Instr_is_csr_instret_a1;

         // For $is_csr_instreth.
         always @(posedge clk) FETCH_Instr_is_csr_instreth_a2 <= FETCH_Instr_is_csr_instreth_a1;

         // For $is_csr_time.
         always @(posedge clk) FETCH_Instr_is_csr_time_a2 <= FETCH_Instr_is_csr_time_a1;

         // For $is_csr_timeh.
         always @(posedge clk) FETCH_Instr_is_csr_timeh_a2 <= FETCH_Instr_is_csr_timeh_a1;

         // For $is_csrrc_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_csrrc_instr_a2 <= FETCH_Instr_is_csrrc_instr_a1;

         // For $is_csrrci_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_csrrci_instr_a2 <= FETCH_Instr_is_csrrci_instr_a1;

         // For $is_csrrs_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_csrrs_instr_a2 <= FETCH_Instr_is_csrrs_instr_a1;

         // For $is_csrrsi_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_csrrsi_instr_a2 <= FETCH_Instr_is_csrrsi_instr_a1;

         // For $is_csrrw_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_csrrw_instr_a2 <= FETCH_Instr_is_csrrw_instr_a1;

         // For $is_csrrwi_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_csrrwi_instr_a2 <= FETCH_Instr_is_csrrwi_instr_a1;

         // For $is_j_type.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_j_type_a2 <= FETCH_Instr_is_j_type_a1;

         // For $is_jal_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_jal_instr_a2 <= FETCH_Instr_is_jal_instr_a1;

         // For $is_jalr_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_jalr_instr_a2 <= FETCH_Instr_is_jalr_instr_a1;

         // For $is_lb_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_lb_instr_a2 <= FETCH_Instr_is_lb_instr_a1;

         // For $is_lbu_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_lbu_instr_a2 <= FETCH_Instr_is_lbu_instr_a1;

         // For $is_lh_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_lh_instr_a2 <= FETCH_Instr_is_lh_instr_a1;

         // For $is_lhu_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_lhu_instr_a2 <= FETCH_Instr_is_lhu_instr_a1;

         // For $is_lui_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_lui_instr_a2 <= FETCH_Instr_is_lui_instr_a1;

         // For $is_lw_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_lw_instr_a2 <= FETCH_Instr_is_lw_instr_a1;

         // For $is_or_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_or_instr_a2 <= FETCH_Instr_is_or_instr_a1;

         // For $is_ori_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_ori_instr_a2 <= FETCH_Instr_is_ori_instr_a1;

         // For $is_sll_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_sll_instr_a2 <= FETCH_Instr_is_sll_instr_a1;

         // For $is_slli_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_slli_instr_a2 <= FETCH_Instr_is_slli_instr_a1;

         // For $is_slt_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_slt_instr_a2 <= FETCH_Instr_is_slt_instr_a1;

         // For $is_slti_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_slti_instr_a2 <= FETCH_Instr_is_slti_instr_a1;

         // For $is_sltiu_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_sltiu_instr_a2 <= FETCH_Instr_is_sltiu_instr_a1;

         // For $is_sltu_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_sltu_instr_a2 <= FETCH_Instr_is_sltu_instr_a1;

         // For $is_srl_sra_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_srl_sra_instr_a2 <= FETCH_Instr_is_srl_sra_instr_a1;

         // For $is_srli_srai_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_srli_srai_instr_a2 <= FETCH_Instr_is_srli_srai_instr_a1;

         // For $is_xor_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_xor_instr_a2 <= FETCH_Instr_is_xor_instr_a1;

         // For $is_xori_instr.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_is_xori_instr_a2 <= FETCH_Instr_is_xori_instr_a1;

         // For $jump.
         always @(posedge clk) FETCH_Instr_jump_a2 <= FETCH_Instr_jump_a1;

         // For $jump_target.
         always @(posedge clkP_FETCH_Instr_jump_a2) FETCH_Instr_jump_target_a2[31:2] <= FETCH_Instr_jump_target_a1[31:2];

         // For $ld.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_ld_a2 <= FETCH_Instr_ld_a1;

         // For $ld_st.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_ld_st_a2 <= FETCH_Instr_ld_st_a1;

         // For $ld_st_half.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_ld_st_half_a2 <= FETCH_Instr_ld_st_half_a1;
         always @(posedge clkP_FETCH_Instr_valid_decode_a3) FETCH_Instr_ld_st_half_a3 <= FETCH_Instr_ld_st_half_a2;

         // For $ld_st_word.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_ld_st_word_a2 <= FETCH_Instr_ld_st_word_a1;
         always @(posedge clkP_FETCH_Instr_valid_decode_a3) FETCH_Instr_ld_st_word_a3 <= FETCH_Instr_ld_st_word_a2;

         // For $misaligned_jump_target.
         always @(posedge clkP_FETCH_Instr_jump_a2) FETCH_Instr_misaligned_jump_target_a2 <= FETCH_Instr_misaligned_jump_target_a1;

         // For $misaligned_pc.
         always @(posedge clkP_FETCH_Instr_valid_decode_branch_a2) FETCH_Instr_misaligned_pc_a2 <= FETCH_Instr_misaligned_pc_a1;

         // For $non_aborting_trap.
         always @(posedge clk) FETCH_Instr_non_aborting_trap_a3 <= FETCH_Instr_non_aborting_trap_a2;

         // For $pred_taken.
         always @(posedge clkP_FETCH_Instr_branch_a2) FETCH_Instr_pred_taken_a2 <= FETCH_Instr_pred_taken_a1;

         // For $raw.
         always @(posedge clkP_FETCH_Instr_fetch_a1) FETCH_Instr_raw_a1[31:0] <= FETCH_Instr_raw_a0[31:0];

         // For $raw_funct3.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_raw_funct3_a2[2] <= FETCH_Instr_raw_funct3_a1[2];
         always @(posedge clkP_FETCH_Instr_valid_decode_a3) FETCH_Instr_raw_funct3_a3[2] <= FETCH_Instr_raw_funct3_a2[2];

         // For $raw_funct7.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_raw_funct7_a2[5] <= FETCH_Instr_raw_funct7_a1[5];

         // For $raw_i_imm.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_raw_i_imm_a2[31:0] <= FETCH_Instr_raw_i_imm_a1[31:0];

         // For $raw_rs1.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_raw_rs1_a2[4:0] <= FETCH_Instr_raw_rs1_a1[4:0];

         // For $raw_s_imm.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_raw_s_imm_a2[31:0] <= FETCH_Instr_raw_s_imm_a1[31:0];

         // For $raw_u_imm.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_raw_u_imm_a2[31:0] <= FETCH_Instr_raw_u_imm_a1[31:0];

         // For $reg_wr_pending.
         always @(posedge clk) FETCH_Instr_reg_wr_pending_a2 <= FETCH_Instr_reg_wr_pending_a1;
         always @(posedge clk) FETCH_Instr_reg_wr_pending_a3 <= FETCH_Instr_reg_wr_pending_a2;

         // For $replay.
         always @(posedge clk) FETCH_Instr_replay_a2 <= FETCH_Instr_replay_a1;
         always @(posedge clk) FETCH_Instr_replay_a3 <= FETCH_Instr_replay_a2;

         // For $reset.
         always @(posedge clk) FETCH_Instr_reset_a0 <= FETCH_Instr_reset_n1;
         always @(posedge clk) FETCH_Instr_reset_a1 <= FETCH_Instr_reset_a0;
         always @(posedge clk) FETCH_Instr_reset_a2 <= FETCH_Instr_reset_a1;
         always @(posedge clk) FETCH_Instr_reset_a3 <= FETCH_Instr_reset_a2;
         always @(posedge clk) FETCH_Instr_reset_a4 <= FETCH_Instr_reset_a3;
         always @(posedge clk) FETCH_Instr_reset_a5 <= FETCH_Instr_reset_a4;
         always @(posedge clk) FETCH_Instr_reset_a6 <= FETCH_Instr_reset_a5;

         // For $returning_ld.
         always @(posedge clk) FETCH_Instr_returning_ld_a1 <= FETCH_Instr_returning_ld_a0;
         always @(posedge clk) FETCH_Instr_returning_ld_a2 <= FETCH_Instr_returning_ld_a1;
         always @(posedge clk) FETCH_Instr_returning_ld_a3 <= FETCH_Instr_returning_ld_a2;

         // For $rslt.
         always @(posedge clk) FETCH_Instr_rslt_a3[31:0] <= FETCH_Instr_rslt_a2[31:0];

         // For $spec_ld.
         always @(posedge clk) FETCH_Instr_spec_ld_a2 <= FETCH_Instr_spec_ld_a1;
         always @(posedge clk) FETCH_Instr_spec_ld_a3 <= FETCH_Instr_spec_ld_a2;

         // For $st.
         always @(posedge clkP_FETCH_Instr_valid_decode_a2) FETCH_Instr_st_a2 <= FETCH_Instr_st_a1;

         // For $st_mask.
         always @(posedge clkP_FETCH_Instr_st_cond_a3) FETCH_Instr_st_mask_a3[3:0] <= FETCH_Instr_st_mask_a2[3:0];

         // For $st_value.
         always @(posedge clkP_FETCH_Instr_st_cond_a3) FETCH_Instr_st_value_a3[31:0] <= FETCH_Instr_st_value_a2[31:0];

         // For $trap_target.
         always @(posedge clk) FETCH_Instr_trap_target_a3[31:2] <= FETCH_Instr_trap_target_a2[31:2];

         // For $valid_decode.
         always @(posedge clk) FETCH_Instr_valid_decode_a2 <= FETCH_Instr_valid_decode_a1;
         always @(posedge clk) FETCH_Instr_valid_decode_a3 <= FETCH_Instr_valid_decode_a2;
         always @(posedge clk) FETCH_Instr_valid_decode_a4 <= FETCH_Instr_valid_decode_a3;
         always @(posedge clk) FETCH_Instr_valid_decode_a5 <= FETCH_Instr_valid_decode_a4;
         always @(posedge clk) FETCH_Instr_valid_decode_a6 <= FETCH_Instr_valid_decode_a5;
         always @(posedge clk) FETCH_Instr_valid_decode_a7 <= FETCH_Instr_valid_decode_a6;
         always @(posedge clk) FETCH_Instr_valid_decode_a8 <= FETCH_Instr_valid_decode_a7;

         // For $valid_decode_branch.
         always @(posedge clk) FETCH_Instr_valid_decode_branch_a2 <= FETCH_Instr_valid_decode_branch_a1;

         // For $valid_dest_reg_valid.
         always @(posedge clk) FETCH_Instr_valid_dest_reg_valid_a3 <= FETCH_Instr_valid_dest_reg_valid_a2;

         // For $valid_ld.
         always @(posedge clk) FETCH_Instr_valid_ld_a3 <= FETCH_Instr_valid_ld_a2;

         // For $valid_st.
         always @(posedge clk) FETCH_Instr_valid_st_a3 <= FETCH_Instr_valid_st_a2;


         //
         // Scope: /original_ld
         //

            // For $addr.
            always @(posedge clkP_FETCH_Instr_returning_ld_a1) FETCH_Instr_OriginalLd_addr_a1[1:0] <= FETCH_Instr_OriginalLd_addr_a0[1:0];
            always @(posedge clkP_FETCH_Instr_returning_ld_a2) FETCH_Instr_OriginalLd_addr_a2[1:0] <= FETCH_Instr_OriginalLd_addr_a1[1:0];

            // For $dest_reg.
            always @(posedge clkP_FETCH_Instr_returning_ld_a1) FETCH_Instr_OriginalLd_dest_reg_a1[4:0] <= FETCH_Instr_OriginalLd_dest_reg_a0[4:0];

            // For $ld_st_half.
            always @(posedge clkP_FETCH_Instr_returning_ld_a1) FETCH_Instr_OriginalLd_ld_st_half_a1 <= FETCH_Instr_OriginalLd_ld_st_half_a0;
            always @(posedge clkP_FETCH_Instr_returning_ld_a2) FETCH_Instr_OriginalLd_ld_st_half_a2 <= FETCH_Instr_OriginalLd_ld_st_half_a1;

            // For $ld_st_word.
            always @(posedge clkP_FETCH_Instr_returning_ld_a1) FETCH_Instr_OriginalLd_ld_st_word_a1 <= FETCH_Instr_OriginalLd_ld_st_word_a0;
            always @(posedge clkP_FETCH_Instr_returning_ld_a2) FETCH_Instr_OriginalLd_ld_st_word_a2 <= FETCH_Instr_OriginalLd_ld_st_word_a1;

            // For $ld_value.
            always @(posedge clkP_FETCH_Instr_returning_ld_a1) FETCH_Instr_OriginalLd_ld_value_a1[31:0] <= FETCH_Instr_OriginalLd_ld_value_a0[31:0];
            always @(posedge clkP_FETCH_Instr_returning_ld_a2) FETCH_Instr_OriginalLd_ld_value_a2[31:0] <= FETCH_Instr_OriginalLd_ld_value_a1[31:0];

            // For $raw_funct3.
            always @(posedge clkP_FETCH_Instr_returning_ld_a1) FETCH_Instr_OriginalLd_raw_funct3_a1[2] <= FETCH_Instr_OriginalLd_raw_funct3_a0[2];
            always @(posedge clkP_FETCH_Instr_returning_ld_a2) FETCH_Instr_OriginalLd_raw_funct3_a2[2] <= FETCH_Instr_OriginalLd_raw_funct3_a1[2];


            //
            // Scope: /src[2:1]
            //
            for (src = 1; src <= 2; src++) begin : L1gen_FETCH_Instr_OriginalLd_Src
               // For $dummy.
               always @(posedge clkP_FETCH_Instr_returning_ld_a1) L1_FETCH_Instr_OriginalLd_Src[src].L1_dummy_a1 <= L1_FETCH_Instr_OriginalLd_Src[src].L1_dummy_a0;
               always @(posedge clkP_FETCH_Instr_returning_ld_a2) L1_FETCH_Instr_OriginalLd_Src[src].L1_dummy_a2 <= L1_FETCH_Instr_OriginalLd_Src[src].L1_dummy_a1;
               always @(posedge clkP_FETCH_Instr_returning_ld_a3) L1_FETCH_Instr_OriginalLd_Src[src].L1_dummy_a3 <= L1_FETCH_Instr_OriginalLd_Src[src].L1_dummy_a2;

            end


         //
         // Scope: /regs[31:1]
         //
         for (regs = 1; regs <= 31; regs++) begin : L1gen_FETCH_Instr_Regs
            // For $pending.
            always @(posedge clk) FETCH_Instr_Regs_pending_a3[regs] <= FETCH_Instr_Regs_pending_a2[regs];

         end

         //
         // Scope: /src[2:1]
         //
         for (src = 1; src <= 2; src++) begin : L1gen_FETCH_Instr_Src
            // For $dummy.
            always @(posedge clk) L1b_FETCH_Instr_Src[src].L1_dummy_a2 <= L1b_FETCH_Instr_Src[src].L1_dummy_a1;
            always @(posedge clk) L1b_FETCH_Instr_Src[src].L1_dummy_a3 <= L1b_FETCH_Instr_Src[src].L1_dummy_a2;

            // For $reg_value.
            always @(posedge clkP_FETCH_Instr_Src_is_reg_condition_a2[src]) L1b_FETCH_Instr_Src[src].L1_reg_value_a2[31:0] <= L1b_FETCH_Instr_Src[src].L1_reg_value_a1[31:0];

         end



   //
   // Scope: |mem
   //


      //
      // Scope: /data
      //

         // For $addr.
         always @(posedge clk) MEM_Data_addr_a4[1:0] <= MEM_Data_addr_a3[1:0];

         // For $dest_reg.
         always @(posedge clk) MEM_Data_dest_reg_a4[4:0] <= MEM_Data_dest_reg_a3[4:0];

         // For $ld_st_half.
         always @(posedge clk) MEM_Data_ld_st_half_a4 <= MEM_Data_ld_st_half_a3;

         // For $ld_st_word.
         always @(posedge clk) MEM_Data_ld_st_word_a4 <= MEM_Data_ld_st_word_a3;

         // For $ld_value.
         always @(posedge clk) MEM_Data_ld_value_a4[31:0] <= MEM_Data_ld_value_a3[31:0];

         // For $raw_funct3.
         always @(posedge clk) MEM_Data_raw_funct3_a4[2] <= MEM_Data_raw_funct3_a3[2];

         // For $valid_ld.
         always @(posedge clk) MEM_Data_valid_ld_a4 <= MEM_Data_valid_ld_a3;


         //
         // Scope: /src[2:1]
         //
         for (src = 1; src <= 2; src++) begin : L1gen_MEM_Data_Src
            // For $dummy.
            always @(posedge clk) L1_MEM_Data_Src[src].L1_dummy_a4 <= L1_MEM_Data_Src[src].L1_dummy_a3;

         end




endgenerate



//
// Gated clocks.
//

generate



   //
   // Scope: |fetch
   //


      //
      // Scope: /instr
      //

         clk_gate gen_clkF_FETCH_Instr_branch_or_reset_a3(clkF_FETCH_Instr_branch_or_reset_a3, clk, FETCH_Instr_branch_or_reset_a2, 1'b1, 1'b0);
         clk_gate gen_clkF_FETCH_Instr_branch_or_reset_a4(clkF_FETCH_Instr_branch_or_reset_a4, clk, FETCH_Instr_branch_or_reset_a3, 1'b1, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_branch_a2(clkP_FETCH_Instr_branch_a2, clk, 1'b1, FETCH_Instr_branch_a1, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_fetch_a1(clkP_FETCH_Instr_fetch_a1, clk, 1'b1, FETCH_Instr_fetch_a0, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_jump_a2(clkP_FETCH_Instr_jump_a2, clk, 1'b1, FETCH_Instr_jump_a1, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_ld_st_cond_a3(clkP_FETCH_Instr_ld_st_cond_a3, clk, 1'b1, FETCH_Instr_ld_st_cond_a2, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_returning_ld_a1(clkP_FETCH_Instr_returning_ld_a1, clk, 1'b1, FETCH_Instr_returning_ld_a0, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_returning_ld_a2(clkP_FETCH_Instr_returning_ld_a2, clk, 1'b1, FETCH_Instr_returning_ld_a1, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_returning_ld_a3(clkP_FETCH_Instr_returning_ld_a3, clk, 1'b1, FETCH_Instr_returning_ld_a2, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_st_cond_a3(clkP_FETCH_Instr_st_cond_a3, clk, 1'b1, FETCH_Instr_st_cond_a2, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_valid_decode_a2(clkP_FETCH_Instr_valid_decode_a2, clk, 1'b1, FETCH_Instr_valid_decode_a1, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_valid_decode_a3(clkP_FETCH_Instr_valid_decode_a3, clk, 1'b1, FETCH_Instr_valid_decode_a2, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_valid_decode_a4(clkP_FETCH_Instr_valid_decode_a4, clk, 1'b1, FETCH_Instr_valid_decode_a3, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_valid_decode_a5(clkP_FETCH_Instr_valid_decode_a5, clk, 1'b1, FETCH_Instr_valid_decode_a4, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_valid_decode_a6(clkP_FETCH_Instr_valid_decode_a6, clk, 1'b1, FETCH_Instr_valid_decode_a5, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_valid_decode_a7(clkP_FETCH_Instr_valid_decode_a7, clk, 1'b1, FETCH_Instr_valid_decode_a6, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_valid_decode_a8(clkP_FETCH_Instr_valid_decode_a8, clk, 1'b1, FETCH_Instr_valid_decode_a7, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_valid_decode_a9(clkP_FETCH_Instr_valid_decode_a9, clk, 1'b1, FETCH_Instr_valid_decode_a8, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_valid_decode_branch_a2(clkP_FETCH_Instr_valid_decode_branch_a2, clk, 1'b1, FETCH_Instr_valid_decode_branch_a1, 1'b0);

         //
         // Scope: /src[2:1]
         //
         for (src = 1; src <= 2; src++) begin : L1clk_FETCH_Instr_Src
            clk_gate gen_clkP_FETCH_Instr_Src_is_reg_condition_a2(clkP_FETCH_Instr_Src_is_reg_condition_a2[src], clk, 1'b1, L1b_FETCH_Instr_Src[src].L1_is_reg_condition_a1, 1'b0);
         end



//---------------------------------------------------------------------------------------------




   // =================
   //
   //    THE MODEL
   //
   // =================
   
   //_\source top.tlv 1746   // Instantiated from top.tlv, 2141 as: m4+cpu()
      
      // Generated logic
      //_\source <builtin> 1   // Instantiated from top.tlv, 1749 as: m4+indirect(M4_isa['_gen'])
         //_\source top.tlv 1125   // Instantiated from built-in definition.
            
            // v---------------------
            // Instruction characterization
         
            // M4 ugliness for instruction characterization.
            
            // For each opcode[6:2]
            // (User ISA Manual 2.2, Table 19.1)
            // Associate opcode[6:2] ([1:0] are 2'b11) with mnemonic and instruction type.
            // Instruction type is not in the table, but there seems to be a single instruction type for each of these,
            // so that is mapped here as well.
            // op5(bits, type, mnemonic)
            /*SV_plus*/
               localparam [4:0] OP5_LOAD = 5'b00000;
               localparam [4:0] OP5_LOAD_FP = 5'b00001;
               localparam [4:0] OP5_CUSTOM_0 = 5'b00010;
               localparam [4:0] OP5_MISC_MEM = 5'b00011;
               localparam [4:0] OP5_OP_IMM = 5'b00100;
               localparam [4:0] OP5_AUIPC = 5'b00101;
               localparam [4:0] OP5_OP_IMM_32 = 5'b00110;
               localparam [4:0] OP5_48B1 = 5'b00111;
               localparam [4:0] OP5_STORE = 5'b01000;
               localparam [4:0] OP5_STORE_FP = 5'b01001;
               localparam [4:0] OP5_CUSTOM_1 = 5'b01010;
               localparam [4:0] OP5_AMO = 5'b01011;  // (R-type, but rs2 = const for some, based on funct7 which doesn't exist for I-type?? R-type w/ ignored R2?)
               localparam [4:0] OP5_OP = 5'b01100;
               localparam [4:0] OP5_LUI = 5'b01101;
               localparam [4:0] OP5_OP_32 = 5'b01110;
               localparam [4:0] OP5_64B = 5'b01111;
               localparam [4:0] OP5_MADD = 5'b10000;
               localparam [4:0] OP5_MSUB = 5'b10001;
               localparam [4:0] OP5_NMSUB = 5'b10010;
               localparam [4:0] OP5_NMADD = 5'b10011;
               localparam [4:0] OP5_OP_FP = 5'b10100;  // (R-type, but rs2 = const for some, based on funct7 which doesn't exist for I-type?? R-type w/ ignored R2?)
               localparam [4:0] OP5_RESERVED_1 = 5'b10101;
               localparam [4:0] OP5_CUSTOM_2_RV128 = 5'b10110;
               localparam [4:0] OP5_48B2 = 5'b10111;
               localparam [4:0] OP5_BRANCH = 5'b11000;
               localparam [4:0] OP5_JALR = 5'b11001;
               localparam [4:0] OP5_RESERVED_2 = 5'b11010;
               localparam [4:0] OP5_JAL = 5'b11011;
               localparam [4:0] OP5_SYSTEM = 5'b11100;
               localparam [4:0] OP5_RESERVED_3 = 5'b11101;
               localparam [4:0] OP5_CUSTOM_3_RV128 = 5'b11110;
               localparam [4:0] OP5_80B = 5'b11111;
               
            /*SV_plus*/
               // Not sure these are ever used.
               localparam INSTR_TYPE_I_MASK = 0 | (1 << 5'b00000) | (1 << 5'b00001) | (1 << 5'b00100) | (1 << 5'b00110) | (1 << 5'b11001) | (1 << 5'b11100); localparam INSTR_TYPE_R_MASK = 0 | (1 << 5'b01100) | (1 << 5'b01110); localparam INSTR_TYPE_RI_MASK = 0 | (1 << 5'b01011) | (1 << 5'b10100); localparam INSTR_TYPE_R4_MASK = 0 | (1 << 5'b10000) | (1 << 5'b10001) | (1 << 5'b10010) | (1 << 5'b10011); localparam INSTR_TYPE_S_MASK = 0 | (1 << 5'b01000) | (1 << 5'b01001); localparam INSTR_TYPE_B_MASK = 0 | (1 << 5'b11000); localparam INSTR_TYPE_J_MASK = 0 | (1 << 5'b11011); localparam INSTR_TYPE_U_MASK = 0 | (1 << 5'b00101) | (1 << 5'b01101); localparam INSTR_TYPE___MASK = 0 | (1 << 5'b00010) | (1 << 5'b00011) | (1 << 5'b00111) | (1 << 5'b01010) | (1 << 5'b01111) | (1 << 5'b10101) | (1 << 5'b10110) | (1 << 5'b10111) | (1 << 5'b11010) | (1 << 5'b11101) | (1 << 5'b11110) | (1 << 5'b11111); 
               
            /*SV_plus*/
               // Instruction characterization.
               // (User ISA Manual 2.2, Table 19.2)
               // instr(type,  // (this is simply verified vs. op5)
               //       |  bit-width,
               //       |  |   extension, 
               //       |  |   |  opcode[6:2],  // (aka op5)
               //       |  |   |  |      func3,   // (if applicable)
               //       |  |   |  |      |    mnemonic)
               localparam [6:0] LUI_INSTR_OPCODE = 7'b0110111;
               localparam [6:0] AUIPC_INSTR_OPCODE = 7'b0010111;
               localparam [6:0] JAL_INSTR_OPCODE = 7'b1101111;
               localparam [6:0] JALR_INSTR_OPCODE = 7'b1100111; localparam [2:0] JALR_INSTR_FUNCT3 = 3'b000;
               localparam [6:0] BEQ_INSTR_OPCODE = 7'b1100011; localparam [2:0] BEQ_INSTR_FUNCT3 = 3'b000;
               localparam [6:0] BNE_INSTR_OPCODE = 7'b1100011; localparam [2:0] BNE_INSTR_FUNCT3 = 3'b001;
               localparam [6:0] BLT_INSTR_OPCODE = 7'b1100011; localparam [2:0] BLT_INSTR_FUNCT3 = 3'b100;
               localparam [6:0] BGE_INSTR_OPCODE = 7'b1100011; localparam [2:0] BGE_INSTR_FUNCT3 = 3'b101;
               localparam [6:0] BLTU_INSTR_OPCODE = 7'b1100011; localparam [2:0] BLTU_INSTR_FUNCT3 = 3'b110;
               localparam [6:0] BGEU_INSTR_OPCODE = 7'b1100011; localparam [2:0] BGEU_INSTR_FUNCT3 = 3'b111;
               localparam [6:0] LB_INSTR_OPCODE = 7'b0000011; localparam [2:0] LB_INSTR_FUNCT3 = 3'b000;
               localparam [6:0] LH_INSTR_OPCODE = 7'b0000011; localparam [2:0] LH_INSTR_FUNCT3 = 3'b001;
               localparam [6:0] LW_INSTR_OPCODE = 7'b0000011; localparam [2:0] LW_INSTR_FUNCT3 = 3'b010;
               localparam [6:0] LBU_INSTR_OPCODE = 7'b0000011; localparam [2:0] LBU_INSTR_FUNCT3 = 3'b100;
               localparam [6:0] LHU_INSTR_OPCODE = 7'b0000011; localparam [2:0] LHU_INSTR_FUNCT3 = 3'b101;
               localparam [6:0] SB_INSTR_OPCODE = 7'b0100011; localparam [2:0] SB_INSTR_FUNCT3 = 3'b000;
               localparam [6:0] SH_INSTR_OPCODE = 7'b0100011; localparam [2:0] SH_INSTR_FUNCT3 = 3'b001;
               localparam [6:0] SW_INSTR_OPCODE = 7'b0100011; localparam [2:0] SW_INSTR_FUNCT3 = 3'b010;
               localparam [6:0] ADDI_INSTR_OPCODE = 7'b0010011; localparam [2:0] ADDI_INSTR_FUNCT3 = 3'b000;
               localparam [6:0] SLTI_INSTR_OPCODE = 7'b0010011; localparam [2:0] SLTI_INSTR_FUNCT3 = 3'b010;
               localparam [6:0] SLTIU_INSTR_OPCODE = 7'b0010011; localparam [2:0] SLTIU_INSTR_FUNCT3 = 3'b011;
               localparam [6:0] XORI_INSTR_OPCODE = 7'b0010011; localparam [2:0] XORI_INSTR_FUNCT3 = 3'b100;
               localparam [6:0] ORI_INSTR_OPCODE = 7'b0010011; localparam [2:0] ORI_INSTR_FUNCT3 = 3'b110;
               localparam [6:0] ANDI_INSTR_OPCODE = 7'b0010011; localparam [2:0] ANDI_INSTR_FUNCT3 = 3'b111;
               localparam [6:0] SLLI_INSTR_OPCODE = 7'b0010011; localparam [2:0] SLLI_INSTR_FUNCT3 = 3'b001;
               localparam [6:0] SRLI_SRAI_INSTR_OPCODE = 7'b0010011; localparam [2:0] SRLI_SRAI_INSTR_FUNCT3 = 3'b101;  // Two instructions distinguished by an immediate bit, treated as a single instruction.
               localparam [6:0] ADD_SUB_INSTR_OPCODE = 7'b0110011; localparam [2:0] ADD_SUB_INSTR_FUNCT3 = 3'b000;  // Treated as a single instruction.
               localparam [6:0] SLL_INSTR_OPCODE = 7'b0110011; localparam [2:0] SLL_INSTR_FUNCT3 = 3'b001;
               localparam [6:0] SLT_INSTR_OPCODE = 7'b0110011; localparam [2:0] SLT_INSTR_FUNCT3 = 3'b010;
               localparam [6:0] SLTU_INSTR_OPCODE = 7'b0110011; localparam [2:0] SLTU_INSTR_FUNCT3 = 3'b011;
               localparam [6:0] XOR_INSTR_OPCODE = 7'b0110011; localparam [2:0] XOR_INSTR_FUNCT3 = 3'b100;
               localparam [6:0] SRL_SRA_INSTR_OPCODE = 7'b0110011; localparam [2:0] SRL_SRA_INSTR_FUNCT3 = 3'b101;  // Treated as a single instruction.
               localparam [6:0] OR_INSTR_OPCODE = 7'b0110011; localparam [2:0] OR_INSTR_FUNCT3 = 3'b110;
               localparam [6:0] AND_INSTR_OPCODE = 7'b0110011; localparam [2:0] AND_INSTR_FUNCT3 = 3'b111;
               //m4_instr(_, 32, I, 00011, 000, FENCE)
               //m4_instr(_, 32, I, 00011, 001, FENCE_I)
               //m4_instr(_, 32, I, 11100, 000, ECALL_EBREAK)  // Two instructions distinguished by an immediate bit, treated as a single instruction.
               localparam [6:0] CSRRW_INSTR_OPCODE = 7'b1110011; localparam [2:0] CSRRW_INSTR_FUNCT3 = 3'b001;
               localparam [6:0] CSRRS_INSTR_OPCODE = 7'b1110011; localparam [2:0] CSRRS_INSTR_FUNCT3 = 3'b010;
               localparam [6:0] CSRRC_INSTR_OPCODE = 7'b1110011; localparam [2:0] CSRRC_INSTR_FUNCT3 = 3'b011;
               localparam [6:0] CSRRWI_INSTR_OPCODE = 7'b1110011; localparam [2:0] CSRRWI_INSTR_FUNCT3 = 3'b101;
               localparam [6:0] CSRRSI_INSTR_OPCODE = 7'b1110011; localparam [2:0] CSRRSI_INSTR_FUNCT3 = 3'b110;
               localparam [6:0] CSRRCI_INSTR_OPCODE = 7'b1110011; localparam [2:0] CSRRCI_INSTR_FUNCT3 = 3'b111;
               
               
               
               
                 // Two instructions distinguished by an immediate bit, treated as a single instruction.
               
               
                 // Two instructions distinguished by an immediate bit, treated as a single instruction.
                 // Two instructions distinguished by an immediate bit, treated as a single instruction.
               
                 // Two instructions distinguished by an immediate bit, treated as a single instruction.
               
               
               
               
               
               
               
               
               
               
               
               
               
               // RV32A and RV64A
               // NOT IMPLEMENTED. These are distinct in the func7 field.
               // RV32F and RV64F
               // NOT IMPLEMENTED.
               // RV32D and RV64D
               // NOT IMPLEMENTED.
         
         
            // ^---------------------
            
         //_\end_source
      //_\end_source
   
      
      // The program in an instruction memory.
      /*SV_plus*/
         logic [31:0] instrs [0:11-1];
      //_\source <builtin> 1   // Instantiated from top.tlv, 2141 as: m4+indirect(M4_isa['_cnt10_prog'])
         //_\source top.tlv 1087   // Instantiated from built-in definition.
            
            /*SV_plus*/
               logic [40*8-1:0] instr_strs [0:11];
               
               // /=====================\
               // | Count to 10 Program |
               // \=====================/
               //
               
               // Add 1,2,3,...,10 (in that order).
               // Store incremental results in memory locations 0..9. (1, 3, 6, 10, ...)
               //
               // Regs:
               // 1: cnt
               // 2: ten
               // 3: out
               // 4: tmp
               // 5: offset
               // 6: store addr
               
               assign instrs = '{
                  {12'b0, 5'd0, ORI_INSTR_FUNCT3, 5'd6, ORI_INSTR_OPCODE},        //     store_addr = 0
                  {12'b1, 5'd0, ORI_INSTR_FUNCT3, 5'd1, ORI_INSTR_OPCODE},        //     cnt = 1
                  {12'b1010, 5'd0, ORI_INSTR_FUNCT3, 5'd2, ORI_INSTR_OPCODE},     //     ten = 10
                  {12'b0, 5'd0, ORI_INSTR_FUNCT3, 5'd3, ORI_INSTR_OPCODE},        //     out = 0
                  {7'b0, 5'd3, 5'd1, ADD_SUB_INSTR_FUNCT3, 5'd3, ADD_SUB_INSTR_OPCODE},       //  -> out += cnt
                  {7'b0000000, 5'd3, 5'd6, SW_INSTR_FUNCT3, 5'b00000, SW_INSTR_OPCODE},         //     store out at store_addr
                  {12'b1, 5'd1, ADDI_INSTR_FUNCT3, 5'd1, ADDI_INSTR_OPCODE},       //     cnt ++
                  {12'b100, 5'd6, ADDI_INSTR_FUNCT3, 5'd6, ADDI_INSTR_OPCODE},     //     store_addr++
                  {1'b1, 6'b111111, 5'd2, 5'd1, BLT_INSTR_FUNCT3, 4'b1000, 1'b1, BLT_INSTR_OPCODE}, //  ^- branch back if cnt < 10
                  {12'b111111111100, 5'd6, LW_INSTR_FUNCT3, 5'd4, LW_INSTR_OPCODE}, //     load the final value into tmp
                  {1'b1, 6'b111110, 5'd2, 5'd1, BGE_INSTR_FUNCT3, 4'b1010, 1'b1, BGE_INSTR_OPCODE}  //     TERMINATE by branching to -1
               };
               
               assign instr_strs = '{ "(I) ORI r6,r0,0                         ",  "(I) ORI r1,r0,1                         ",  "(I) ORI r2,r0,1010                      ",  "(I) ORI r3,r0,0                         ",  "(R) ADD_SUB r3,r1,r3                    ",  "(S) SW r6,r3,0                          ",  "(I) ADDI r1,r1,1                        ",  "(I) ADDI r6,r6,100                      ",  "(B) BLT r1,r2,1111111110000             ",  "(I) LW r4,r6,111111111100               ",  "(B) BGE r1,r2,1111111010100             ",  "END                                     "};
            
         //_\end_source
      //_\end_source
      
   
   
      // /=========\
      // | The CPU |
      // \=========/
   
      //_|fetch
         //_/instr
            // Provide a longer reset to cover the pipeline depth.
            //_@-1
               assign FETCH_Instr_Cnt_n2[7:0] = reset        ? 8'b0 :       // reset
                            FETCH_Instr_Cnt_n1 == 8'hFF ? 8'hFF :      // max out to avoid wrapping
                                            FETCH_Instr_Cnt_n1 + 8'b1; // increment
               assign FETCH_Instr_reset_n1 = reset || FETCH_Instr_Cnt_n1 < 10;
            
            //_@0
               assign FETCH_Instr_fetch_a0 = ! FETCH_Instr_reset_a0;  // always fetch
               //_?$fetch
   
                  // =====
                  // Fetch
                  // =====
   
                  // Fetch the raw instruction from program memory (or, for formal, tie it off).
                  
                  
                  
                  assign FETCH_Instr_raw_a0[31:0] = instrs[FETCH_Instr_Pc_a0[5:2]];
                  
            //_@0
               
               // ========
               // Overview
               // ========
               
               // Terminology:
               //
               // Instruction: An instruction, as viewed by the CPU pipeline (i.e. ld and returning_ld are separate instructions,
               //              and the returning_ld and the instruction it clobbers are one in the same).
               // ISA Instruction: An instruction, as defined by the ISA.
               // Good-Path (vs. Bad-Path): On the proper flow of execution of the program, excluding aborted instructions.
               // Path (of an instruction): The sequence of instructions that led to a particular instruction.
               // Current Path: The sequence of instructions fetched by next-PC logic that are not known to be bad-path.
               // Redirect: Adjust the PC from the predicted next-PC.
               // Redirect Shadow: Between the instruction causing the redirect and the redirect target instruction.
               // Bubbles: The cycles in the redirect shadow.
               // Commit: Results are made visible to subsequent instructions.
               // Abort: Do not commit. All aborts are also redirects and put the instruction on bad path. Non-aborting
               //        redirects do not mark the triggering instruction as bad-path. Aborts mask future redirects on the
               //        aborted instruction.
               // Retire: Commit results of an ISA instruction.
               
               // Control flow:
               //
               // Redirects include (earliest to latest):
               //   o Returning load: (aborting) A returning load clobbers an instruction and takes its slot, resulting in a
               //                     one-cycle redirect to repeat the clobbered instruction.
               //   o Predict-taken branch: A predicted-taken branch must determine the target before it can redirect the PC.
               //                           (This might be followed up by a mispredition.)
               //   o Replay: (aborting) Replay the same instruction (because a source register is pending (awaiting a returning_ld))
               //   o Jump: A jump instruction.
               //   o Mispredicted branch: A branch condition was mispredicted.
               //   o Aborting traps: (aborting) illegal instructions, others?
               //   o Non-aborting traps: misaligned PC target
               
               // ==============
               // Redirect Logic
               // ==============
                               
               // PC logic will redirect the PC for conditions on current-path instructions. PC logic keeps track of which
               // instructions are on the current path with a $GoodPathMask. $GoodPathMask[n] of an instruction indicates
               // whether the instruction n instructions prior to this instruction is on its path.
               //
               //                 $GoodPathMask for Redir'edX => {o,X,o,o,y,y,o,o} == {1,1,1,1,0,0,1,1}
               // Waterfall View: |
               //                 V
               // 0)       oooooooo                  Good-path
               // 1) InstX  ooooooXo  (Non-aborting) Good-path
               // 2)         ooooooxx
               // 3) InstY    ooYyyxxx  (Aborting)
               // 4) InstZ     ooyyxZxx
               // 5) Redir'edY  oyyxxxxx
               // 6) TargetY     ooxxxxxx
               // 7) Redir'edX    oxxxxxxx
               // 8) TargetX       oooooooo          Good-path
               // 9) Not redir'edZ  oooooooo         Good-path
               //
               // Above depicts a waterfall diagram where three triggering redirection conditions X, Y, and Z are detected on three different
               // instructions. A trigger in the 1st depicted stage, M4_NEXT_PC_STAGE, results in a zero-bubble redirect so it would be
               // a condition that is factored directly into the next-PC logic of the triggering instruction, and it would have
               // no impact on the $GoodPathMask.
               //
               // Waveform View:
               //
               //   Inst 0123456789
               //        ---------- /
               // GPM[7]        ooxxxxxxoo
               // GPM[6]       oXxxxxxxoo
               // GPM[5]      oooxZxxxoo
               // GPM[4]     oooyxxxxoo
               // GPM[3]    oooyyxxxoo
               // GPM[2]   oooYyyxxoo
               // GPM[1]  oooooyoxoo
               // GPM[0] oooooooooo
               //          /
               //         Triggers for Inst 3
               //
               // In the waveform view, the mask shifts up each cycle, as instructions age, and trigger conditions mask instructions
               // in the shadow, down to the redirect target (GPM[0]).
               //
               // Terminology:
               //   Triggering instruction: The instruction on which the condition is detected.
               //   Redirected instruction: The instruction whose next PC is redirected.
               //   Redirection target instruction: The first new-path instruction resulting from the redirection.
               //
               // Above, Y redirects first, though it is for a later instruction than X. The redirections for X and Y are taken
               // because their instructions are on the path of the redirected instructions. Z is not on the path of its
               // potentially-redirected instruction, so no redirection happens.
               //
               // For simultaneous conditions on different instructions, the PC must redirect to the earlier instruction's
               // redirect target, so later-stage redirects take priority in the PC-mux.
               //
               // Aborting redirects result in the aborting instruction being marked as bad-path. Aborted instructions will
               // not commit. Subsequent redirect conditions on aborting instructions are ignored. (For conditions within the
               // same stage, this is accomplished by the PC-mux prioritization.)
               
               
               // Macros are defined elsewhere based on the ordered set of conditions that generate code here.
               
               // Redirect Shadow
               // A mask of stages ahead of this one (older) in which instructions are on the path of this instruction.
               // Index 1 is ahead by 1, etc.
               // In the example above, $GoodPathMask for Redir'edX == {0,0,0,0,1,1,0,0}
               //     (Looking up in the waterfall diagram from its first "o", in reverse order {o,X,o,o,y,y,o,o}.)
               // The LSB is fetch-valid. It only exists for m4_valid_as_of macro.
               assign FETCH_Instr_next_good_path_mask_a0[3+1:0] =
                  // Shift up and mask w/ redirect conditions.
                  {FETCH_Instr_GoodPathMask_a0[3:0]
                   // & terms for each condition (order doesn't matter since masks are the same within a cycle)
                    & ((FETCH_Instr_returning_ld_a0 && !(1'b0) && FETCH_Instr_GoodPathMask_a0[0]) ? {{3{1'b1}}, {1{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_pred_taken_branch_a1 && !(1'b0 || FETCH_Instr_returning_ld_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {{3{1'b1}}, {1{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_replay_a1 && !(1'b0 || FETCH_Instr_returning_ld_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_jump_a2 && !(1'b0 || FETCH_Instr_returning_ld_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_mispred_branch_a2 && !(1'b0 || FETCH_Instr_returning_ld_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_indirect_jump_a2 && !(1'b0 || FETCH_Instr_returning_ld_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_aborting_trap_a3 && !(1'b0 || FETCH_Instr_returning_ld_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {{0{1'b1}}, {4{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_non_aborting_trap_a3 && !(1'b0 || FETCH_Instr_returning_ld_a3 || FETCH_Instr_replay_a3 || FETCH_Instr_aborting_trap_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {{1{1'b1}}, {3{1'b0}}} : {4{1'b1}}),
                   1'b1}; // Shift in 1'b1 (fetch-valid).
               
               assign FETCH_Instr_GoodPathMask_n1[3+1:0] =
                  FETCH_Instr_reset_n1 ? 5'b0 :  // All bad-path (through self) on reset (next mask based on next reset).
                  FETCH_Instr_next_good_path_mask_a0;
               
               
               
               
               
                  
                   
                   
               
                  
                  
               
               
               
               // A returning load clobbers the instruction.
               // (Could do this with lower latency. Right now it goes through memory pipeline $ANY, and
               //  it is non-speculative. Both could easily be fixed.)
               assign FETCH_Instr_returning_ld_a0 = MEM_Data_valid_ld_a4 && 1'b1;
               // Recirculate returning load.
               //_?$returning_ld
                  // This scope holds the original load for a returning load.
                  //_/original_ld
                     assign {FETCH_Instr_OriginalLd_addr_a0[1:0], FETCH_Instr_OriginalLd_dest_reg_a0[4:0], FETCH_Instr_OriginalLd_ld_st_half_a0, FETCH_Instr_OriginalLd_ld_st_word_a0, FETCH_Instr_OriginalLd_ld_value_a0[31:0], FETCH_Instr_OriginalLd_raw_funct3_a0[2]} = {MEM_Data_addr_a4, MEM_Data_dest_reg_a4, MEM_Data_ld_st_half_a4, MEM_Data_ld_st_word_a4, MEM_Data_ld_value_a4, MEM_Data_raw_funct3_a4};
                     for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_OriginalLd_Src wire L1_dummy_a0; reg  L1_dummy_a1, L1_dummy_a2, L1_dummy_a3; //_/src
                        assign {L1_dummy_a0} = {L1_MEM_Data_Src[src].L1_dummy_a4}; end
               
               // Next PC
               assign FETCH_Instr_Pc_n1[31:2] =
                  FETCH_Instr_reset_a0 ? 30'b0 :
                  // ? : terms for each condition (order does matter)
                  (FETCH_Instr_non_aborting_trap_a3 && !(1'b0 || FETCH_Instr_returning_ld_a3 || FETCH_Instr_replay_a3 || FETCH_Instr_aborting_trap_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? FETCH_Instr_trap_target_a3 : (FETCH_Instr_aborting_trap_a3 && !(1'b0 || FETCH_Instr_returning_ld_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? FETCH_Instr_trap_target_a3 : (FETCH_Instr_indirect_jump_a2 && !(1'b0 || FETCH_Instr_returning_ld_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? FETCH_Instr_indirect_jump_target_a2 : (FETCH_Instr_mispred_branch_a2 && !(1'b0 || FETCH_Instr_returning_ld_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? FETCH_Instr_branch_redir_pc_a2 : (FETCH_Instr_jump_a2 && !(1'b0 || FETCH_Instr_returning_ld_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? FETCH_Instr_jump_target_a2 : (FETCH_Instr_replay_a1 && !(1'b0 || FETCH_Instr_returning_ld_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? FETCH_Instr_Pc_a1 : (FETCH_Instr_pred_taken_branch_a1 && !(1'b0 || FETCH_Instr_returning_ld_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? FETCH_Instr_branch_target_a1 : (FETCH_Instr_returning_ld_a0 && !(1'b0) && FETCH_Instr_GoodPathMask_a0[0]) ? FETCH_Instr_Pc_a0 :         
                           FETCH_Instr_Pc_a0 + 30'b1;
            
            //_@1
   
               // ======
               // DECODE
               // ======
   
               // Decode of the fetched instruction
               assign FETCH_Instr_valid_decode_a1 = FETCH_Instr_fetch_a1;  // Always decode if we fetch.
               assign FETCH_Instr_valid_decode_branch_a1 = FETCH_Instr_valid_decode_a1 && FETCH_Instr_branch_a1;
               //_\source <builtin> 1   // Instantiated from top.tlv, 1944 as: m4+indirect(M4_isa['_decode'])
                  //_\source top.tlv 1366   // Instantiated from built-in definition.
                     // TODO: ?$valid_<stage> conditioning should be replaced by use of m4_valid_as_of(M4_BLAH_STAGE).
                     //_?$valid_decode
                  
                        // =================================
                  
                        // Extract fields of $raw (instruction) into $raw_<field>[x:0].
                        assign {FETCH_Instr_raw_funct7_a1[6:0], FETCH_Instr_raw_rs2_a1[4:0], FETCH_Instr_raw_rs1_a1[4:0], FETCH_Instr_raw_funct3_a1[2:0], FETCH_Instr_raw_rd_a1[4:0], FETCH_Instr_raw_op5_a1[4:0], FETCH_Instr_raw_op2_a1[1:0]} = FETCH_Instr_raw_a1;
                        `BOGUS_USE(FETCH_Instr_raw_funct7_a1 FETCH_Instr_raw_op2_a1)  // Delete once its used.
                        // Extract immediate fields into type-specific signals.
                        // (User ISA Manual 2.2, Fig. 2.4)
                        assign FETCH_Instr_raw_i_imm_a1[31:0] = {{21{FETCH_Instr_raw_a1[31]}}, FETCH_Instr_raw_a1[30:20]};
                        assign FETCH_Instr_raw_s_imm_a1[31:0] = {{21{FETCH_Instr_raw_a1[31]}}, FETCH_Instr_raw_a1[30:25], FETCH_Instr_raw_a1[11:7]};
                        assign FETCH_Instr_raw_b_imm_a1[31:0] = {{20{FETCH_Instr_raw_a1[31]}}, FETCH_Instr_raw_a1[7], FETCH_Instr_raw_a1[30:25], FETCH_Instr_raw_a1[11:8], 1'b0};
                        assign FETCH_Instr_raw_u_imm_a1[31:0] = {FETCH_Instr_raw_a1[31:12], {12{1'b0}}};
                        assign FETCH_Instr_raw_j_imm_a1[31:0] = {{12{FETCH_Instr_raw_a1[31]}}, FETCH_Instr_raw_a1[19:12], FETCH_Instr_raw_a1[20], FETCH_Instr_raw_a1[30:21], 1'b0};
                        // Extract other type/instruction-specific fields.
                        assign FETCH_Instr_raw_shamt_a1[6:0] = FETCH_Instr_raw_a1[26:20];
                        assign FETCH_Instr_raw_aq_a1 = FETCH_Instr_raw_a1[26];
                        assign FETCH_Instr_raw_rl_a1 = FETCH_Instr_raw_a1[25];
                        assign FETCH_Instr_raw_rs3_a1[4:0] = FETCH_Instr_raw_a1[31:27];
                        assign FETCH_Instr_raw_rm_a1[2:0] = FETCH_Instr_raw_funct3_a1;
                        `BOGUS_USE(FETCH_Instr_raw_shamt_a1 FETCH_Instr_raw_aq_a1 FETCH_Instr_raw_rl_a1 FETCH_Instr_raw_rs3_a1 FETCH_Instr_raw_rm_a1)  // Avoid "unused" messages. Remove these as they become used.
                  
                        // Instruction type decode
                        /*SV_plus*/
                           assign FETCH_Instr_is_i_type_a1 = INSTR_TYPE_I_MASK[FETCH_Instr_raw_op5_a1]; assign FETCH_Instr_is_r_type_a1 = INSTR_TYPE_R_MASK[FETCH_Instr_raw_op5_a1]; assign FETCH_Instr_is_ri_type_a1 = INSTR_TYPE_RI_MASK[FETCH_Instr_raw_op5_a1]; assign FETCH_Instr_is_r4_type_a1 = INSTR_TYPE_R4_MASK[FETCH_Instr_raw_op5_a1]; assign FETCH_Instr_is_s_type_a1 = INSTR_TYPE_S_MASK[FETCH_Instr_raw_op5_a1]; assign FETCH_Instr_is_b_type_a1 = INSTR_TYPE_B_MASK[FETCH_Instr_raw_op5_a1]; assign FETCH_Instr_is_j_type_a1 = INSTR_TYPE_J_MASK[FETCH_Instr_raw_op5_a1]; assign FETCH_Instr_is_u_type_a1 = INSTR_TYPE_U_MASK[FETCH_Instr_raw_op5_a1]; assign FETCH_Instr_is___type_a1 = INSTR_TYPE___MASK[FETCH_Instr_raw_op5_a1]; 
                  
                        // Instruction decode.
                        //_\source top.tlv 1358   // Instantiated from top.tlv, 1395 as: m4+riscv_decode_expr()
                           assign FETCH_Instr_is_lui_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01101;
                           assign FETCH_Instr_is_auipc_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00101;
                           assign FETCH_Instr_is_jal_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11011;
                           assign FETCH_Instr_is_jalr_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11001 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                           assign FETCH_Instr_is_beq_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                           assign FETCH_Instr_is_bne_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                           assign FETCH_Instr_is_blt_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b100;
                           assign FETCH_Instr_is_bge_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b101;
                           assign FETCH_Instr_is_bltu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b110;
                           assign FETCH_Instr_is_bgeu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b111;
                           assign FETCH_Instr_is_lb_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                           assign FETCH_Instr_is_lh_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                           assign FETCH_Instr_is_lw_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b010;
                           assign FETCH_Instr_is_lbu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b100;
                           assign FETCH_Instr_is_lhu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b101;
                           assign FETCH_Instr_is_sb_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01000 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                           assign FETCH_Instr_is_sh_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01000 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                           assign FETCH_Instr_is_sw_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01000 && FETCH_Instr_raw_funct3_a1 == 3'b010;
                           assign FETCH_Instr_is_addi_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                           assign FETCH_Instr_is_slti_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b010;
                           assign FETCH_Instr_is_sltiu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b011;
                           assign FETCH_Instr_is_xori_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b100;
                           assign FETCH_Instr_is_ori_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b110;
                           assign FETCH_Instr_is_andi_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b111;
                           assign FETCH_Instr_is_slli_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                           assign FETCH_Instr_is_srli_srai_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b101;
                           assign FETCH_Instr_is_add_sub_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                           assign FETCH_Instr_is_sll_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                           assign FETCH_Instr_is_slt_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b010;
                           assign FETCH_Instr_is_sltu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b011;
                           assign FETCH_Instr_is_xor_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b100;
                           assign FETCH_Instr_is_srl_sra_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b101;
                           assign FETCH_Instr_is_or_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b110;
                           assign FETCH_Instr_is_and_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b111;
                           assign FETCH_Instr_is_csrrw_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                           assign FETCH_Instr_is_csrrs_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b010;
                           assign FETCH_Instr_is_csrrc_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b011;
                           assign FETCH_Instr_is_csrrwi_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b101;
                           assign FETCH_Instr_is_csrrsi_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b110;
                           assign FETCH_Instr_is_csrrci_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b111;
                           
                        //_\end_source
                  
                        assign FETCH_Instr_illegal_a1 = 1'b1 && ! FETCH_Instr_is_lui_instr_a1 && ! FETCH_Instr_is_auipc_instr_a1 && ! FETCH_Instr_is_jal_instr_a1 && ! FETCH_Instr_is_jalr_instr_a1 && ! FETCH_Instr_is_beq_instr_a1 && ! FETCH_Instr_is_bne_instr_a1 && ! FETCH_Instr_is_blt_instr_a1 && ! FETCH_Instr_is_bge_instr_a1 && ! FETCH_Instr_is_bltu_instr_a1 && ! FETCH_Instr_is_bgeu_instr_a1 && ! FETCH_Instr_is_lb_instr_a1 && ! FETCH_Instr_is_lh_instr_a1 && ! FETCH_Instr_is_lw_instr_a1 && ! FETCH_Instr_is_lbu_instr_a1 && ! FETCH_Instr_is_lhu_instr_a1 && ! FETCH_Instr_is_sb_instr_a1 && ! FETCH_Instr_is_sh_instr_a1 && ! FETCH_Instr_is_sw_instr_a1 && ! FETCH_Instr_is_addi_instr_a1 && ! FETCH_Instr_is_slti_instr_a1 && ! FETCH_Instr_is_sltiu_instr_a1 && ! FETCH_Instr_is_xori_instr_a1 && ! FETCH_Instr_is_ori_instr_a1 && ! FETCH_Instr_is_andi_instr_a1 && ! FETCH_Instr_is_slli_instr_a1 && ! FETCH_Instr_is_srli_srai_instr_a1 && ! FETCH_Instr_is_add_sub_instr_a1 && ! FETCH_Instr_is_sll_instr_a1 && ! FETCH_Instr_is_slt_instr_a1 && ! FETCH_Instr_is_sltu_instr_a1 && ! FETCH_Instr_is_xor_instr_a1 && ! FETCH_Instr_is_srl_sra_instr_a1 && ! FETCH_Instr_is_or_instr_a1 && ! FETCH_Instr_is_and_instr_a1 && ! FETCH_Instr_is_csrrw_instr_a1 && ! FETCH_Instr_is_csrrs_instr_a1 && ! FETCH_Instr_is_csrrc_instr_a1 && ! FETCH_Instr_is_csrrwi_instr_a1 && ! FETCH_Instr_is_csrrsi_instr_a1 && ! FETCH_Instr_is_csrrci_instr_a1;
                        assign FETCH_Instr_conditional_branch_a1 = FETCH_Instr_is_b_type_a1;
                     assign FETCH_Instr_jump_a1 = FETCH_Instr_is_jal_instr_a1;  // "Jump" in RISC-V means unconditional. (JALR is a separate redirect condition.)
                     assign FETCH_Instr_branch_a1 = FETCH_Instr_is_b_type_a1;
                     assign FETCH_Instr_indirect_jump_a1 = FETCH_Instr_is_jalr_instr_a1;
                     //_?$valid_decode
                        assign FETCH_Instr_ld_a1 = FETCH_Instr_raw_a1[6:3] == 4'b0;
                        assign FETCH_Instr_st_a1 = FETCH_Instr_is_s_type_a1;
                        assign FETCH_Instr_ld_st_a1 = FETCH_Instr_ld_a1 || FETCH_Instr_st_a1;
                        assign FETCH_Instr_ld_st_word_a1 = FETCH_Instr_ld_st_a1 && (FETCH_Instr_raw_funct3_a1[1] == 1'b1);
                        assign FETCH_Instr_ld_st_half_a1 = FETCH_Instr_ld_st_a1 && (FETCH_Instr_raw_funct3_a1[1:0] == 2'b01);
                        //$ld_st_byte = $ld_st && ($raw_funct3[1:0] == 2'b00);
                        `BOGUS_USE(FETCH_Instr_is___type_a1 FETCH_Instr_is_u_type_a1)
                  
                        // Output signals.
                        for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_Src wire L1_is_reg_a1; wire [4:0] L1_reg_a1; //_/src
                           // Reg valid for this source, based on instruction type.
                           assign L1_is_reg_a1 = FETCH_Instr_is_r_type_a1 || FETCH_Instr_is_r4_type_a1 || (FETCH_Instr_is_i_type_a1 && (src == 1)) || FETCH_Instr_is_ri_type_a1 || FETCH_Instr_is_s_type_a1 || FETCH_Instr_is_b_type_a1;
                           assign L1_reg_a1[4:0] = (src == 1) ? FETCH_Instr_raw_rs1_a1 : FETCH_Instr_raw_rs2_a1; end
                             
                        // For debug.
                        assign FETCH_Instr_mnemonic_a1[10*8-1:0] = FETCH_Instr_is_lui_instr_a1 ? "LUI       " : FETCH_Instr_is_auipc_instr_a1 ? "AUIPC     " : FETCH_Instr_is_jal_instr_a1 ? "JAL       " : FETCH_Instr_is_jalr_instr_a1 ? "JALR      " : FETCH_Instr_is_beq_instr_a1 ? "BEQ       " : FETCH_Instr_is_bne_instr_a1 ? "BNE       " : FETCH_Instr_is_blt_instr_a1 ? "BLT       " : FETCH_Instr_is_bge_instr_a1 ? "BGE       " : FETCH_Instr_is_bltu_instr_a1 ? "BLTU      " : FETCH_Instr_is_bgeu_instr_a1 ? "BGEU      " : FETCH_Instr_is_lb_instr_a1 ? "LB        " : FETCH_Instr_is_lh_instr_a1 ? "LH        " : FETCH_Instr_is_lw_instr_a1 ? "LW        " : FETCH_Instr_is_lbu_instr_a1 ? "LBU       " : FETCH_Instr_is_lhu_instr_a1 ? "LHU       " : FETCH_Instr_is_sb_instr_a1 ? "SB        " : FETCH_Instr_is_sh_instr_a1 ? "SH        " : FETCH_Instr_is_sw_instr_a1 ? "SW        " : FETCH_Instr_is_addi_instr_a1 ? "ADDI      " : FETCH_Instr_is_slti_instr_a1 ? "SLTI      " : FETCH_Instr_is_sltiu_instr_a1 ? "SLTIU     " : FETCH_Instr_is_xori_instr_a1 ? "XORI      " : FETCH_Instr_is_ori_instr_a1 ? "ORI       " : FETCH_Instr_is_andi_instr_a1 ? "ANDI      " : FETCH_Instr_is_slli_instr_a1 ? "SLLI      " : FETCH_Instr_is_srli_srai_instr_a1 ? "SRLI_SRAI " : FETCH_Instr_is_add_sub_instr_a1 ? "ADD_SUB   " : FETCH_Instr_is_sll_instr_a1 ? "SLL       " : FETCH_Instr_is_slt_instr_a1 ? "SLT       " : FETCH_Instr_is_sltu_instr_a1 ? "SLTU      " : FETCH_Instr_is_xor_instr_a1 ? "XOR       " : FETCH_Instr_is_srl_sra_instr_a1 ? "SRL_SRA   " : FETCH_Instr_is_or_instr_a1 ? "OR        " : FETCH_Instr_is_and_instr_a1 ? "AND       " : FETCH_Instr_is_csrrw_instr_a1 ? "CSRRW     " : FETCH_Instr_is_csrrs_instr_a1 ? "CSRRS     " : FETCH_Instr_is_csrrc_instr_a1 ? "CSRRC     " : FETCH_Instr_is_csrrwi_instr_a1 ? "CSRRWI    " : FETCH_Instr_is_csrrsi_instr_a1 ? "CSRRSI    " : FETCH_Instr_is_csrrci_instr_a1 ? "CSRRCI    " :  "ILLEGAL   ";
                        `BOGUS_USE(FETCH_Instr_mnemonic_a1)
                     // Condition signals must not themselves be conditioned (currently).
                     assign FETCH_Instr_dest_reg_a1[4:0] = FETCH_Instr_returning_ld_a1 ? FETCH_Instr_OriginalLd_dest_reg_a1 : FETCH_Instr_raw_rd_a1;
                     assign FETCH_Instr_dest_reg_valid_a1 = ((FETCH_Instr_valid_decode_a1 && ! FETCH_Instr_is_s_type_a1 && ! FETCH_Instr_is_b_type_a1) || FETCH_Instr_returning_ld_a1) &&
                                       | FETCH_Instr_dest_reg_a1;   // r0 not valid.
                     // Actually load.
                     assign FETCH_Instr_spec_ld_a1 = FETCH_Instr_valid_decode_a1 && FETCH_Instr_ld_a1;
                     
                  //_\end_source
               //_\end_source
            //_\source <builtin> 1   // Instantiated from top.tlv, 1945 as: m4+indirect(['branch_pred_']M4_BRANCH_PRED)
               //_\source top.tlv 1724   // Instantiated from built-in definition.
                  //_@1
                     //_?$branch
                        assign FETCH_Instr_pred_taken_a1 = FETCH_Instr_BranchState_a3[1];
                  //_@2
                     assign FETCH_Instr_branch_or_reset_a2 = FETCH_Instr_branch_a2 || FETCH_Instr_reset_a2;
                     //_?$branch_or_reset
                        assign FETCH_Instr_BranchState_a1[1:0] =
                           FETCH_Instr_reset_a2 ? 2'b01 :
                           FETCH_Instr_taken_a2 ? (FETCH_Instr_BranchState_a2 == 2'b11 ? FETCH_Instr_BranchState_a2[1:0] : FETCH_Instr_BranchState_a2 + 2'b1) :
                                    (FETCH_Instr_BranchState_a2 == 2'b00 ? FETCH_Instr_BranchState_a2[1:0] : FETCH_Instr_BranchState_a2 - 2'b1);
               //_\end_source
            //_\end_source
            
            //_@1
               // Pending value to write to dest reg. Loads (not replaced by returning ld) write pending.
               assign FETCH_Instr_reg_wr_pending_a1 = FETCH_Instr_ld_a1 && ! FETCH_Instr_returning_ld_a1 && 1'b1;
               `BOGUS_USE(FETCH_Instr_reg_wr_pending_a1)  // Not used if no bypass and no pending.
               
               // ======
               // Reg Rd
               // ======
               
               // Obtain source register values and pending bit for source registers. Bypass up to 3
               // stages.
               // It is not necessary to bypass pending, as we could delay the replay, but we implement
               // bypass for performance.
               // Pending has an additional read for the dest register as we need to replay for write-after-write
               // hazard as well as write-after-read. To replay for dest write with the same timing, we must also
               // bypass the dest reg's pending bit.
               //_/regs
               for (src = 1; src <= 2; src++) begin : L1b_FETCH_Instr_Src wire L1_dummy_a1; reg  L1_dummy_a2, L1_dummy_a3; wire L1_is_reg_condition_a1; wire L1_pending_a1; wire [31:0] L1_reg_value_a1; reg  [31:0] L1_reg_value_a2; //_/src
                  assign L1_is_reg_condition_a1 = L1_FETCH_Instr_Src[src].L1_is_reg_a1 && FETCH_Instr_valid_decode_a1;  // Note: $is_reg can be set for RISC-V sr0.
                  //_?$is_reg_condition
                     assign {L1_reg_value_a1[31:0], L1_pending_a1} =
                        (L1_FETCH_Instr_Src[src].L1_reg_a1 == 5'b0) ? {32'b0, 1'b0} :  // Read r0 as 0 (not pending).
                        // Bypass stages. Both register and pending are bypassed.
                        // Bypassed registers must be from instructions that are good-path as of this instruction or are returning_ld.
                        (FETCH_Instr_dest_reg_valid_a2 && (FETCH_Instr_GoodPathMask_a1[1] || FETCH_Instr_returning_ld_a2) && (FETCH_Instr_dest_reg_a2 == L1_FETCH_Instr_Src[src].L1_reg_a1)) ? {FETCH_Instr_rslt_a2, FETCH_Instr_reg_wr_pending_a2} :
                        (FETCH_Instr_dest_reg_valid_a3 && (FETCH_Instr_GoodPathMask_a1[2] || FETCH_Instr_returning_ld_a3) && (FETCH_Instr_dest_reg_a3 == L1_FETCH_Instr_Src[src].L1_reg_a1)) ? {FETCH_Instr_rslt_a3, FETCH_Instr_reg_wr_pending_a3} :
                        
                        {FETCH_Instr_Regs_value_a3[L1_FETCH_Instr_Src[src].L1_reg_a1], FETCH_Instr_Regs_pending_a3[L1_FETCH_Instr_Src[src].L1_reg_a1]};
                  // Replay if this source register is pending.
                  assign FETCH_Instr_Src_replay_a1[src] = L1_is_reg_condition_a1 && L1_pending_a1;
                  assign L1_dummy_a1 = 1'b0; end  // Dummy signal to pull through $ANY expressions when not building verification harness (since SandPiper currently complains about empty $ANY).
               // Also replay for pending dest reg to keep writes in order. Bypass dest reg pending to support this.
               assign FETCH_Instr_is_dest_condition_a1 = FETCH_Instr_dest_reg_valid_a1 && FETCH_Instr_valid_decode_a1;  // Note, $dest_reg_valid is 0 for RISC-V sr0.
               //_?$is_dest_condition
                  assign FETCH_Instr_dest_pending_a1 =
                     (FETCH_Instr_dest_reg_a1 == 5'b0) ? 1'b0 :  // Read r0 as 0 (not pending). Not actually necessary, but it cuts off read of non-existent rs0, which might be an issue for formal verif tools.
                     // Bypass stages. Both register and pending are bypassed.
                     (FETCH_Instr_dest_reg_valid_a2 && (FETCH_Instr_GoodPathMask_a1[1] || FETCH_Instr_returning_ld_a2) && (FETCH_Instr_dest_reg_a2 == FETCH_Instr_dest_reg_a1)) ? FETCH_Instr_reg_wr_pending_a2 :
                     (FETCH_Instr_dest_reg_valid_a3 && (FETCH_Instr_GoodPathMask_a1[2] || FETCH_Instr_returning_ld_a3) && (FETCH_Instr_dest_reg_a3 == FETCH_Instr_dest_reg_a1)) ? FETCH_Instr_reg_wr_pending_a3 :
                     
                     FETCH_Instr_Regs_pending_a3[FETCH_Instr_dest_reg_a1];
               // Combine replay conditions for pending source or dest registers.
               assign FETCH_Instr_replay_a1 = | FETCH_Instr_Src_replay_a1 || (FETCH_Instr_is_dest_condition_a1 && FETCH_Instr_dest_pending_a1);
            
            
            // =======
            // Execute
            // =======
            //_\source <builtin> 1   // Instantiated from top.tlv, 1995 as: m4+indirect(M4_isa['_exe'], @M4_EXECUTE_STAGE, @M4_RESULT_STAGE)
               //_\source top.tlv 1427   // Instantiated from built-in definition.
                  //_@1
                     //_?$valid_decode_branch
                        assign FETCH_Instr_branch_target_a1[31:2] = FETCH_Instr_Pc_a1[31:2] + FETCH_Instr_raw_b_imm_a1[31:2];
                        assign FETCH_Instr_misaligned_pc_a1 = | FETCH_Instr_raw_b_imm_a1[1:0];
                     //_?$jump  // (JAL, not JALR)
                        assign FETCH_Instr_jump_target_a1[31:2] = FETCH_Instr_Pc_a1[31:2] + FETCH_Instr_raw_j_imm_a1[31:2];
                        assign FETCH_Instr_misaligned_jump_target_a1 = FETCH_Instr_raw_j_imm_a1[1];
                  //_@2
                     // Execution.
                     assign FETCH_Instr_valid_exe_a2 = FETCH_Instr_valid_decode_a2; // Execute if we decoded.
                     
                     // Compute results for each instruction, independent of decode (power-hungry, but fast).
                     //_?$valid_exe
                        assign FETCH_Instr_equal_a2 = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 == L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                     //_?$branch
                        assign FETCH_Instr_taken_a2 =
                           FETCH_Instr_is_j_type_a2 ||
                           (FETCH_Instr_is_beq_instr_a2 && FETCH_Instr_equal_a2) ||
                           (FETCH_Instr_is_bne_instr_a2 && ! FETCH_Instr_equal_a2) ||
                           ((FETCH_Instr_is_blt_instr_a2 || FETCH_Instr_is_bltu_instr_a2 || FETCH_Instr_is_bge_instr_a2 || FETCH_Instr_is_bgeu_instr_a2) &&
                            ((FETCH_Instr_is_bge_instr_a2 || FETCH_Instr_is_bgeu_instr_a2) ^
                             (({(FETCH_Instr_is_blt_instr_a2 ^ L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31]), L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31-1:0]} <
                              {(FETCH_Instr_is_blt_instr_a2 ^ L1b_FETCH_Instr_Src[2].L1_reg_value_a2[31]), L1b_FETCH_Instr_Src[2].L1_reg_value_a2[31-1:0]}) ^ ((L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] != L1b_FETCH_Instr_Src[2].L1_reg_value_a2[31]) & FETCH_Instr_is_bge_instr_a2)
                             )
                            )
                           );
                     //_?$indirect_jump  // (JALR)
                        assign FETCH_Instr_indirect_jump_full_target_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 + FETCH_Instr_raw_i_imm_a2;
                        assign FETCH_Instr_indirect_jump_target_a2[31:2] = FETCH_Instr_indirect_jump_full_target_a2[31:2];
                        assign FETCH_Instr_misaligned_indirect_jump_target_a2 = FETCH_Instr_indirect_jump_full_target_a2[1];
                     //_?$valid_exe
                        // Compute each individual instruction result, combined per-instruction by a macro.
                        
                        assign FETCH_Instr_lui_rslt_a2[31:0] = {FETCH_Instr_raw_u_imm_a2[31:12], 12'b0};
                        assign FETCH_Instr_auipc_rslt_a2[31:0] = {FETCH_Instr_Pc_a2, 2'b0} + FETCH_Instr_raw_u_imm_a2;
                        assign FETCH_Instr_jal_rslt_a2[31:0] = {FETCH_Instr_Pc_a2, 2'b0} + 4;
                        assign FETCH_Instr_jalr_rslt_a2[31:0] = {FETCH_Instr_Pc_a2, 2'b0} + 4;
                        // Load instructions. If returning ld is enabled, load instructions write no meaningful result, so we use zeros.
                        
                        assign FETCH_Instr_lb_rslt_a2[31:0] = 32'b0;
                        assign FETCH_Instr_lh_rslt_a2[31:0] = 32'b0;
                        assign FETCH_Instr_lw_rslt_a2[31:0] = 32'b0;
                        assign FETCH_Instr_lbu_rslt_a2[31:0] = 32'b0;
                        assign FETCH_Instr_lhu_rslt_a2[31:0] = 32'b0;
                        
                        
                        
                        
                        
                        
                        
                        assign FETCH_Instr_addi_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 + FETCH_Instr_raw_i_imm_a2;  // Note: this has its own adder; could share w/ add/sub.
                        assign FETCH_Instr_xori_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 ^ FETCH_Instr_raw_i_imm_a2;
                        assign FETCH_Instr_ori_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 | FETCH_Instr_raw_i_imm_a2;
                        assign FETCH_Instr_andi_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 & FETCH_Instr_raw_i_imm_a2;
                        assign FETCH_Instr_slli_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 << FETCH_Instr_raw_i_imm_a2[5:0];
                        assign FETCH_Instr_srli_intermediate_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 >> FETCH_Instr_raw_i_imm_a2[5:0];
                        assign FETCH_Instr_srai_intermediate_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] ? FETCH_Instr_srli_intermediate_rslt_a2 | ((32'b0 - 1) << (32 - FETCH_Instr_raw_i_imm_a2[5:0]) ): FETCH_Instr_srli_intermediate_rslt_a2;
                        assign FETCH_Instr_sra_intermediate_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] ? FETCH_Instr_srl_intermediate_rslt_a2 | ((32'b0 - 1) << (32 - L1b_FETCH_Instr_Src[2].L1_reg_value_a2[4:0]) ): FETCH_Instr_srl_intermediate_rslt_a2;
                        assign FETCH_Instr_srl_intermediate_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 >> L1b_FETCH_Instr_Src[2].L1_reg_value_a2[4:0];
                        assign FETCH_Instr_slti_rslt_a2[31:0] =  (L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] == FETCH_Instr_raw_i_imm_a2[31]) ? FETCH_Instr_sltiu_rslt_a2 : {31'b0,L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31]};
                        assign FETCH_Instr_sltiu_rslt_a2[31:0] = (L1b_FETCH_Instr_Src[1].L1_reg_value_a2 < FETCH_Instr_raw_i_imm_a2) ? 1 : 0;
                        assign FETCH_Instr_srli_srai_rslt_a2[31:0] = (FETCH_Instr_raw_i_imm_a2[10] == 1) ? FETCH_Instr_srai_intermediate_rslt_a2 : FETCH_Instr_srli_intermediate_rslt_a2;
                        assign FETCH_Instr_add_sub_rslt_a2[31:0] =  (FETCH_Instr_raw_funct7_a2[5] == 1) ?  L1b_FETCH_Instr_Src[1].L1_reg_value_a2 - L1b_FETCH_Instr_Src[2].L1_reg_value_a2 : L1b_FETCH_Instr_Src[1].L1_reg_value_a2 + L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                        assign FETCH_Instr_sll_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 << L1b_FETCH_Instr_Src[2].L1_reg_value_a2[4:0];
                        assign FETCH_Instr_slt_rslt_a2[31:0] = (L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] == L1b_FETCH_Instr_Src[2].L1_reg_value_a2[31]) ? FETCH_Instr_sltu_rslt_a2 : {31'b0,L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31]};
                        assign FETCH_Instr_sltu_rslt_a2[31:0] = (L1b_FETCH_Instr_Src[1].L1_reg_value_a2 < L1b_FETCH_Instr_Src[2].L1_reg_value_a2) ? 1 : 0;
                        assign FETCH_Instr_xor_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 ^ L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                        assign FETCH_Instr_srl_sra_rslt_a2[31:0] = (FETCH_Instr_raw_funct7_a2[5] == 1) ? FETCH_Instr_sra_intermediate_rslt_a2 : FETCH_Instr_srl_intermediate_rslt_a2;
                        assign FETCH_Instr_or_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 | L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                        assign FETCH_Instr_and_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 & L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                        // TODO: CSR read instructions have the same result expression. Synthesis might not optimize optimally.
                        assign FETCH_Instr_csrrw_rslt_a2[31:0]  = FETCH_Instr_is_csr_instreth_a2 ? FETCH_Instr_csr_instreth_a2 : FETCH_Instr_is_csr_instret_a2 ? FETCH_Instr_csr_instret_a2 : FETCH_Instr_is_csr_timeh_a2 ? FETCH_Instr_csr_timeh_a2 : FETCH_Instr_is_csr_time_a2 ? FETCH_Instr_csr_time_a2 : FETCH_Instr_is_csr_cycleh_a2 ? FETCH_Instr_csr_cycleh_a2 : FETCH_Instr_is_csr_cycle_a2 ? FETCH_Instr_csr_cycle_a2 : 32'bx;
                        assign FETCH_Instr_csrrs_rslt_a2[31:0]  = FETCH_Instr_is_csr_instreth_a2 ? FETCH_Instr_csr_instreth_a2 : FETCH_Instr_is_csr_instret_a2 ? FETCH_Instr_csr_instret_a2 : FETCH_Instr_is_csr_timeh_a2 ? FETCH_Instr_csr_timeh_a2 : FETCH_Instr_is_csr_time_a2 ? FETCH_Instr_csr_time_a2 : FETCH_Instr_is_csr_cycleh_a2 ? FETCH_Instr_csr_cycleh_a2 : FETCH_Instr_is_csr_cycle_a2 ? FETCH_Instr_csr_cycle_a2 : 32'bx;
                        assign FETCH_Instr_csrrc_rslt_a2[31:0]  = FETCH_Instr_is_csr_instreth_a2 ? FETCH_Instr_csr_instreth_a2 : FETCH_Instr_is_csr_instret_a2 ? FETCH_Instr_csr_instret_a2 : FETCH_Instr_is_csr_timeh_a2 ? FETCH_Instr_csr_timeh_a2 : FETCH_Instr_is_csr_time_a2 ? FETCH_Instr_csr_time_a2 : FETCH_Instr_is_csr_cycleh_a2 ? FETCH_Instr_csr_cycleh_a2 : FETCH_Instr_is_csr_cycle_a2 ? FETCH_Instr_csr_cycle_a2 : 32'bx;
                        assign FETCH_Instr_csrrwi_rslt_a2[31:0] = FETCH_Instr_is_csr_instreth_a2 ? FETCH_Instr_csr_instreth_a2 : FETCH_Instr_is_csr_instret_a2 ? FETCH_Instr_csr_instret_a2 : FETCH_Instr_is_csr_timeh_a2 ? FETCH_Instr_csr_timeh_a2 : FETCH_Instr_is_csr_time_a2 ? FETCH_Instr_csr_time_a2 : FETCH_Instr_is_csr_cycleh_a2 ? FETCH_Instr_csr_cycleh_a2 : FETCH_Instr_is_csr_cycle_a2 ? FETCH_Instr_csr_cycle_a2 : 32'bx;
                        assign FETCH_Instr_csrrsi_rslt_a2[31:0] = FETCH_Instr_is_csr_instreth_a2 ? FETCH_Instr_csr_instreth_a2 : FETCH_Instr_is_csr_instret_a2 ? FETCH_Instr_csr_instret_a2 : FETCH_Instr_is_csr_timeh_a2 ? FETCH_Instr_csr_timeh_a2 : FETCH_Instr_is_csr_time_a2 ? FETCH_Instr_csr_time_a2 : FETCH_Instr_is_csr_cycleh_a2 ? FETCH_Instr_csr_cycleh_a2 : FETCH_Instr_is_csr_cycle_a2 ? FETCH_Instr_csr_cycle_a2 : 32'bx;
                        assign FETCH_Instr_csrrci_rslt_a2[31:0] = FETCH_Instr_is_csr_instreth_a2 ? FETCH_Instr_csr_instreth_a2 : FETCH_Instr_is_csr_instret_a2 ? FETCH_Instr_csr_instret_a2 : FETCH_Instr_is_csr_timeh_a2 ? FETCH_Instr_csr_timeh_a2 : FETCH_Instr_is_csr_time_a2 ? FETCH_Instr_csr_time_a2 : FETCH_Instr_is_csr_cycleh_a2 ? FETCH_Instr_csr_cycleh_a2 : FETCH_Instr_is_csr_cycle_a2 ? FETCH_Instr_csr_cycle_a2 : 32'bx;
                        
                  // CSR logic
                  // ---------
                  //_\source top.tlv 1294   // Instantiated from top.tlv, 1509 as: m4+riscv_csrs((m4_csrs))
                     
                     //_\source top.tlv 1264   // Instantiated from top.tlv, 2141 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                        //--------------
                        // CSR CYCLE
                        //--------------
                        //_@1
                           assign FETCH_Instr_is_csr_cycle_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC00;
                        //_@2
                           // CSR update. Counting on synthesis to optimize each bit, based on 32'b1.
                           
                           
                           // hw_wr_mask conditioned by hw_wr.
                           assign FETCH_Instr_csr_cycle_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_cycle_hw_wr_a2}} & FETCH_Instr_csr_cycle_hw_wr_mask_a2;
                           // The CSR value, updated by side-effect writes (if 1).
                           assign FETCH_Instr_upd_csr_cycle_a2[31:0] =
                                (FETCH_Instr_csr_cycle_hw_wr_en_mask_a2 & FETCH_Instr_csr_cycle_hw_wr_value_a2) | (! FETCH_Instr_csr_cycle_hw_wr_en_mask_a2 & FETCH_Instr_csr_cycle_a2);
                           // Next value of the CSR.
                           assign FETCH_Instr_csr_cycle_masked_wr_value_a2[31:0] =
                                FETCH_Instr_masked_csr_wr_value_a2[31:0] & 32'b1;
                           assign FETCH_Instr_csr_cycle_a1[31:0] =
                                FETCH_Instr_reset_a2 ? 32'b0 :
                                ((FETCH_Instr_is_csrrw_instr_a2 || FETCH_Instr_is_csrrwi_instr_a2) && FETCH_Instr_is_csr_cycle_a2)
                                       ? FETCH_Instr_csr_cycle_masked_wr_value_a2 | (FETCH_Instr_upd_csr_cycle_a2 & ! 32'b1) :
                                ((FETCH_Instr_is_csrrs_instr_a2 || FETCH_Instr_is_csrrsi_instr_a2) && FETCH_Instr_is_csr_cycle_a2)
                                       ? FETCH_Instr_upd_csr_cycle_a2 |   FETCH_Instr_csr_cycle_masked_wr_value_a2 :
                                ((FETCH_Instr_is_csrrc_instr_a2 || FETCH_Instr_is_csrrci_instr_a2) && FETCH_Instr_is_csr_cycle_a2)
                                       ? FETCH_Instr_upd_csr_cycle_a2 & ~ FETCH_Instr_csr_cycle_masked_wr_value_a2 :
                                // retain
                                         FETCH_Instr_upd_csr_cycle_a2;
                     //_\end_source
                     
                     //_\source top.tlv 1264   // Instantiated from top.tlv, 2141 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                        //--------------
                        // CSR CYCLEH
                        //--------------
                        //_@1
                           assign FETCH_Instr_is_csr_cycleh_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC80;
                        //_@2
                           // CSR update. Counting on synthesis to optimize each bit, based on 32'b1.
                           
                           
                           // hw_wr_mask conditioned by hw_wr.
                           assign FETCH_Instr_csr_cycleh_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_cycleh_hw_wr_a2}} & FETCH_Instr_csr_cycleh_hw_wr_mask_a2;
                           // The CSR value, updated by side-effect writes (if 1).
                           assign FETCH_Instr_upd_csr_cycleh_a2[31:0] =
                                (FETCH_Instr_csr_cycleh_hw_wr_en_mask_a2 & FETCH_Instr_csr_cycleh_hw_wr_value_a2) | (! FETCH_Instr_csr_cycleh_hw_wr_en_mask_a2 & FETCH_Instr_csr_cycleh_a2);
                           // Next value of the CSR.
                           assign FETCH_Instr_csr_cycleh_masked_wr_value_a2[31:0] =
                                FETCH_Instr_masked_csr_wr_value_a2[31:0] & 32'b1;
                           assign FETCH_Instr_csr_cycleh_a1[31:0] =
                                FETCH_Instr_reset_a2 ? 32'b0 :
                                ((FETCH_Instr_is_csrrw_instr_a2 || FETCH_Instr_is_csrrwi_instr_a2) && FETCH_Instr_is_csr_cycleh_a2)
                                       ? FETCH_Instr_csr_cycleh_masked_wr_value_a2 | (FETCH_Instr_upd_csr_cycleh_a2 & ! 32'b1) :
                                ((FETCH_Instr_is_csrrs_instr_a2 || FETCH_Instr_is_csrrsi_instr_a2) && FETCH_Instr_is_csr_cycleh_a2)
                                       ? FETCH_Instr_upd_csr_cycleh_a2 |   FETCH_Instr_csr_cycleh_masked_wr_value_a2 :
                                ((FETCH_Instr_is_csrrc_instr_a2 || FETCH_Instr_is_csrrci_instr_a2) && FETCH_Instr_is_csr_cycleh_a2)
                                       ? FETCH_Instr_upd_csr_cycleh_a2 & ~ FETCH_Instr_csr_cycleh_masked_wr_value_a2 :
                                // retain
                                         FETCH_Instr_upd_csr_cycleh_a2;
                     //_\end_source
                     
                     //_\source top.tlv 1264   // Instantiated from top.tlv, 2141 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                        //--------------
                        // CSR TIME
                        //--------------
                        //_@1
                           assign FETCH_Instr_is_csr_time_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC01;
                        //_@2
                           // CSR update. Counting on synthesis to optimize each bit, based on 32'b1.
                           
                           
                           // hw_wr_mask conditioned by hw_wr.
                           assign FETCH_Instr_csr_time_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_time_hw_wr_a2}} & FETCH_Instr_csr_time_hw_wr_mask_a2;
                           // The CSR value, updated by side-effect writes (if 1).
                           assign FETCH_Instr_upd_csr_time_a2[31:0] =
                                (FETCH_Instr_csr_time_hw_wr_en_mask_a2 & FETCH_Instr_csr_time_hw_wr_value_a2) | (! FETCH_Instr_csr_time_hw_wr_en_mask_a2 & FETCH_Instr_csr_time_a2);
                           // Next value of the CSR.
                           assign FETCH_Instr_csr_time_masked_wr_value_a2[31:0] =
                                FETCH_Instr_masked_csr_wr_value_a2[31:0] & 32'b1;
                           assign FETCH_Instr_csr_time_a1[31:0] =
                                FETCH_Instr_reset_a2 ? 32'b0 :
                                ((FETCH_Instr_is_csrrw_instr_a2 || FETCH_Instr_is_csrrwi_instr_a2) && FETCH_Instr_is_csr_time_a2)
                                       ? FETCH_Instr_csr_time_masked_wr_value_a2 | (FETCH_Instr_upd_csr_time_a2 & ! 32'b1) :
                                ((FETCH_Instr_is_csrrs_instr_a2 || FETCH_Instr_is_csrrsi_instr_a2) && FETCH_Instr_is_csr_time_a2)
                                       ? FETCH_Instr_upd_csr_time_a2 |   FETCH_Instr_csr_time_masked_wr_value_a2 :
                                ((FETCH_Instr_is_csrrc_instr_a2 || FETCH_Instr_is_csrrci_instr_a2) && FETCH_Instr_is_csr_time_a2)
                                       ? FETCH_Instr_upd_csr_time_a2 & ~ FETCH_Instr_csr_time_masked_wr_value_a2 :
                                // retain
                                         FETCH_Instr_upd_csr_time_a2;
                     //_\end_source
                     
                     //_\source top.tlv 1264   // Instantiated from top.tlv, 2141 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                        //--------------
                        // CSR TIMEH
                        //--------------
                        //_@1
                           assign FETCH_Instr_is_csr_timeh_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC81;
                        //_@2
                           // CSR update. Counting on synthesis to optimize each bit, based on 32'b1.
                           
                           
                           // hw_wr_mask conditioned by hw_wr.
                           assign FETCH_Instr_csr_timeh_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_timeh_hw_wr_a2}} & FETCH_Instr_csr_timeh_hw_wr_mask_a2;
                           // The CSR value, updated by side-effect writes (if 1).
                           assign FETCH_Instr_upd_csr_timeh_a2[31:0] =
                                (FETCH_Instr_csr_timeh_hw_wr_en_mask_a2 & FETCH_Instr_csr_timeh_hw_wr_value_a2) | (! FETCH_Instr_csr_timeh_hw_wr_en_mask_a2 & FETCH_Instr_csr_timeh_a2);
                           // Next value of the CSR.
                           assign FETCH_Instr_csr_timeh_masked_wr_value_a2[31:0] =
                                FETCH_Instr_masked_csr_wr_value_a2[31:0] & 32'b1;
                           assign FETCH_Instr_csr_timeh_a1[31:0] =
                                FETCH_Instr_reset_a2 ? 32'b0 :
                                ((FETCH_Instr_is_csrrw_instr_a2 || FETCH_Instr_is_csrrwi_instr_a2) && FETCH_Instr_is_csr_timeh_a2)
                                       ? FETCH_Instr_csr_timeh_masked_wr_value_a2 | (FETCH_Instr_upd_csr_timeh_a2 & ! 32'b1) :
                                ((FETCH_Instr_is_csrrs_instr_a2 || FETCH_Instr_is_csrrsi_instr_a2) && FETCH_Instr_is_csr_timeh_a2)
                                       ? FETCH_Instr_upd_csr_timeh_a2 |   FETCH_Instr_csr_timeh_masked_wr_value_a2 :
                                ((FETCH_Instr_is_csrrc_instr_a2 || FETCH_Instr_is_csrrci_instr_a2) && FETCH_Instr_is_csr_timeh_a2)
                                       ? FETCH_Instr_upd_csr_timeh_a2 & ~ FETCH_Instr_csr_timeh_masked_wr_value_a2 :
                                // retain
                                         FETCH_Instr_upd_csr_timeh_a2;
                     //_\end_source
                     
                     //_\source top.tlv 1264   // Instantiated from top.tlv, 2141 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                        //--------------
                        // CSR INSTRET
                        //--------------
                        //_@1
                           assign FETCH_Instr_is_csr_instret_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC02;
                        //_@2
                           // CSR update. Counting on synthesis to optimize each bit, based on 32'b1.
                           
                           
                           // hw_wr_mask conditioned by hw_wr.
                           assign FETCH_Instr_csr_instret_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_instret_hw_wr_a2}} & FETCH_Instr_csr_instret_hw_wr_mask_a2;
                           // The CSR value, updated by side-effect writes (if 1).
                           assign FETCH_Instr_upd_csr_instret_a2[31:0] =
                                (FETCH_Instr_csr_instret_hw_wr_en_mask_a2 & FETCH_Instr_csr_instret_hw_wr_value_a2) | (! FETCH_Instr_csr_instret_hw_wr_en_mask_a2 & FETCH_Instr_csr_instret_a2);
                           // Next value of the CSR.
                           assign FETCH_Instr_csr_instret_masked_wr_value_a2[31:0] =
                                FETCH_Instr_masked_csr_wr_value_a2[31:0] & 32'b1;
                           assign FETCH_Instr_csr_instret_a1[31:0] =
                                FETCH_Instr_reset_a2 ? 32'b0 :
                                ((FETCH_Instr_is_csrrw_instr_a2 || FETCH_Instr_is_csrrwi_instr_a2) && FETCH_Instr_is_csr_instret_a2)
                                       ? FETCH_Instr_csr_instret_masked_wr_value_a2 | (FETCH_Instr_upd_csr_instret_a2 & ! 32'b1) :
                                ((FETCH_Instr_is_csrrs_instr_a2 || FETCH_Instr_is_csrrsi_instr_a2) && FETCH_Instr_is_csr_instret_a2)
                                       ? FETCH_Instr_upd_csr_instret_a2 |   FETCH_Instr_csr_instret_masked_wr_value_a2 :
                                ((FETCH_Instr_is_csrrc_instr_a2 || FETCH_Instr_is_csrrci_instr_a2) && FETCH_Instr_is_csr_instret_a2)
                                       ? FETCH_Instr_upd_csr_instret_a2 & ~ FETCH_Instr_csr_instret_masked_wr_value_a2 :
                                // retain
                                         FETCH_Instr_upd_csr_instret_a2;
                     //_\end_source
                     
                     //_\source top.tlv 1264   // Instantiated from top.tlv, 2141 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                        //--------------
                        // CSR INSTRETH
                        //--------------
                        //_@1
                           assign FETCH_Instr_is_csr_instreth_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC82;
                        //_@2
                           // CSR update. Counting on synthesis to optimize each bit, based on 32'b1.
                           
                           
                           // hw_wr_mask conditioned by hw_wr.
                           assign FETCH_Instr_csr_instreth_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_instreth_hw_wr_a2}} & FETCH_Instr_csr_instreth_hw_wr_mask_a2;
                           // The CSR value, updated by side-effect writes (if 1).
                           assign FETCH_Instr_upd_csr_instreth_a2[31:0] =
                                (FETCH_Instr_csr_instreth_hw_wr_en_mask_a2 & FETCH_Instr_csr_instreth_hw_wr_value_a2) | (! FETCH_Instr_csr_instreth_hw_wr_en_mask_a2 & FETCH_Instr_csr_instreth_a2);
                           // Next value of the CSR.
                           assign FETCH_Instr_csr_instreth_masked_wr_value_a2[31:0] =
                                FETCH_Instr_masked_csr_wr_value_a2[31:0] & 32'b1;
                           assign FETCH_Instr_csr_instreth_a1[31:0] =
                                FETCH_Instr_reset_a2 ? 32'b0 :
                                ((FETCH_Instr_is_csrrw_instr_a2 || FETCH_Instr_is_csrrwi_instr_a2) && FETCH_Instr_is_csr_instreth_a2)
                                       ? FETCH_Instr_csr_instreth_masked_wr_value_a2 | (FETCH_Instr_upd_csr_instreth_a2 & ! 32'b1) :
                                ((FETCH_Instr_is_csrrs_instr_a2 || FETCH_Instr_is_csrrsi_instr_a2) && FETCH_Instr_is_csr_instreth_a2)
                                       ? FETCH_Instr_upd_csr_instreth_a2 |   FETCH_Instr_csr_instreth_masked_wr_value_a2 :
                                ((FETCH_Instr_is_csrrc_instr_a2 || FETCH_Instr_is_csrrci_instr_a2) && FETCH_Instr_is_csr_instreth_a2)
                                       ? FETCH_Instr_upd_csr_instreth_a2 & ~ FETCH_Instr_csr_instreth_masked_wr_value_a2 :
                                // retain
                                         FETCH_Instr_upd_csr_instreth_a2;
                     //_\end_source
                     
                  //_\end_source
                  //_@2
                     //_\source top.tlv 1299   // Instantiated from top.tlv, 1511 as: m4+riscv_csr_logic()
                        
                        // CSR write value for CSR write instructions.
                        assign FETCH_Instr_masked_csr_wr_value_a2[31:0] = FETCH_Instr_raw_funct3_a2[2] ? {27'b0, FETCH_Instr_raw_rs1_a2} : L1b_FETCH_Instr_Src[1].L1_reg_value_a2;
                        
                     
                        // Counter CSR
                        //
                        
                        // Count within time unit. This is not reset on writes to time CSR, so time CSR is only accurate to time unit.
                        assign FETCH_Instr_RemainingCyclesWithinTimeUnit_a1[30-1:0] =
                             (FETCH_Instr_reset_a2 || FETCH_Instr_time_unit_expires_a2) ?
                                    30'd999999999 :
                                    FETCH_Instr_RemainingCyclesWithinTimeUnit_a2 - 30'b1;
                        assign FETCH_Instr_time_unit_expires_a2 = !( | FETCH_Instr_RemainingCyclesWithinTimeUnit_a2);  // reaches zero
                        
                        assign FETCH_Instr_full_csr_cycle_hw_wr_value_a2[63:0]   = {FETCH_Instr_csr_cycleh_a2,   FETCH_Instr_csr_cycle_a2  } + 64'b1;
                        assign FETCH_Instr_full_csr_time_hw_wr_value_a2[63:0]    = {FETCH_Instr_csr_timeh_a2,    FETCH_Instr_csr_time_a2   } + 64'b1;
                        assign FETCH_Instr_full_csr_instret_hw_wr_value_a2[63:0] = {FETCH_Instr_csr_instreth_a2, FETCH_Instr_csr_instret_a2} + 64'b1;
                     
                        // CSR write signals.
                        assign FETCH_Instr_csr_cycle_hw_wr_a2 = 1'b1;
                        assign FETCH_Instr_csr_cycle_hw_wr_mask_a2 = {32{1'b1}};
                        assign FETCH_Instr_csr_cycle_hw_wr_value_a2 = FETCH_Instr_full_csr_cycle_hw_wr_value_a2[31:0];
                        assign FETCH_Instr_csr_cycleh_hw_wr_a2 = 1'b1;
                        assign FETCH_Instr_csr_cycleh_hw_wr_mask_a2 = {32{1'b1}};
                        assign FETCH_Instr_csr_cycleh_hw_wr_value_a2 = FETCH_Instr_full_csr_cycle_hw_wr_value_a2[63:32];
                        assign FETCH_Instr_csr_time_hw_wr_a2 = FETCH_Instr_time_unit_expires_a2;
                        assign FETCH_Instr_csr_time_hw_wr_mask_a2 = {32{1'b1}};
                        assign FETCH_Instr_csr_time_hw_wr_value_a2 = FETCH_Instr_full_csr_time_hw_wr_value_a2[31:0];
                        assign FETCH_Instr_csr_timeh_hw_wr_a2 = FETCH_Instr_time_unit_expires_a2;
                        assign FETCH_Instr_csr_timeh_hw_wr_mask_a2 = {32{1'b1}};
                        assign FETCH_Instr_csr_timeh_hw_wr_value_a2 = FETCH_Instr_full_csr_time_hw_wr_value_a2[63:32];
                        assign FETCH_Instr_csr_instret_hw_wr_a2 = FETCH_Instr_commit_a2;
                        assign FETCH_Instr_csr_instret_hw_wr_mask_a2 = {32{1'b1}};
                        assign FETCH_Instr_csr_instret_hw_wr_value_a2 = FETCH_Instr_full_csr_instret_hw_wr_value_a2[31:0];
                        assign FETCH_Instr_csr_instreth_hw_wr_a2 = FETCH_Instr_commit_a2;
                        assign FETCH_Instr_csr_instreth_hw_wr_mask_a2 = {32{1'b1}};
                        assign FETCH_Instr_csr_instreth_hw_wr_value_a2 = FETCH_Instr_full_csr_instret_hw_wr_value_a2[63:32];
                        
                        
                        // For multicore CSRs:
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                     //_\end_source
                     // CSR trap.
                     assign FETCH_Instr_is_csr_instr_a2 = FETCH_Instr_is_csrrw_instr_a2 ||
                                     FETCH_Instr_is_csrrs_instr_a2 ||
                                     FETCH_Instr_is_csrrc_instr_a2 ||
                                     FETCH_Instr_is_csrrwi_instr_a2 ||
                                     FETCH_Instr_is_csrrsi_instr_a2 ||
                                     FETCH_Instr_is_csrrci_instr_a2;
                     assign FETCH_Instr_valid_csr_a2 = FETCH_Instr_is_csr_instreth_a2 ? FETCH_Instr_csr_instreth_a2 : FETCH_Instr_is_csr_instret_a2 ? FETCH_Instr_csr_instret_a2 : FETCH_Instr_is_csr_timeh_a2 ? FETCH_Instr_csr_timeh_a2 : FETCH_Instr_is_csr_time_a2 ? FETCH_Instr_csr_time_a2 : FETCH_Instr_is_csr_cycleh_a2 ? FETCH_Instr_csr_cycleh_a2 : FETCH_Instr_is_csr_cycle_a2 ? FETCH_Instr_csr_cycle_a2 : 32'bx || FETCH_Instr_is_csr_instreth_a2;
                     assign FETCH_Instr_csr_trap_a2 = FETCH_Instr_is_csr_instr_a2 && FETCH_Instr_valid_csr_a2;
                     
                     // Memory inputs.
                     //_?$valid_exe
                        assign FETCH_Instr_unnatural_addr_trap_a2 = (FETCH_Instr_ld_st_word_a2 && (FETCH_Instr_addr_a2[1:0] != 2'b00)) || (FETCH_Instr_ld_st_half_a2 && FETCH_Instr_addr_a2[0]);
                     assign FETCH_Instr_ld_st_cond_a2 = FETCH_Instr_ld_st_a2 && FETCH_Instr_valid_exe_a2;
                     //_?$ld_st_cond
                        assign FETCH_Instr_addr_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 + (FETCH_Instr_ld_a2 ? FETCH_Instr_raw_i_imm_a2 : FETCH_Instr_raw_s_imm_a2);
                        
                        // Hardware assumes natural alignment. Otherwise, trap, and handle in s/w (though no s/w provided).
                     assign FETCH_Instr_st_cond_a2 = FETCH_Instr_st_a2 && FETCH_Instr_valid_exe_a2;
                     //_?$st_cond
                        // Provide a value to store, naturally-aligned to memory, that will work regardless of the lower $addr bits.
                        assign FETCH_Instr_st_reg_value_a2[31:0] = L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                        assign FETCH_Instr_st_value_a2[31:0] =
                             FETCH_Instr_ld_st_word_a2 ? FETCH_Instr_st_reg_value_a2 :            // word
                             FETCH_Instr_ld_st_half_a2 ? {2{FETCH_Instr_st_reg_value_a2[15:0]}} : // half
                                           {4{FETCH_Instr_st_reg_value_a2[7:0]}};   // byte
                        assign FETCH_Instr_st_mask_a2[3:0] =
                             FETCH_Instr_ld_st_word_a2 ? 4'hf :                     // word
                             FETCH_Instr_ld_st_half_a2 ? (FETCH_Instr_addr_a2[1] ? 4'hc : 4'h3) : // half
                                           (4'h1 << FETCH_Instr_addr_a2[1:0]);      // byte
                     // Swizzle bytes for load result (assuming natural alignment).
                     //_?$returning_ld
                        //_/original_ld
                           // (Verilator didn't like indexing $ld_value by signal math, so we do these the long way.)
                           assign FETCH_Instr_OriginalLd_sign_bit_a2 =
                              ! FETCH_Instr_OriginalLd_raw_funct3_a2[2] && (  // Signed && ...
                                 FETCH_Instr_OriginalLd_ld_st_word_a2 ? FETCH_Instr_OriginalLd_ld_value_a2[31] :
                                 FETCH_Instr_OriginalLd_ld_st_half_a2 ? (FETCH_Instr_OriginalLd_addr_a2[1] ? FETCH_Instr_OriginalLd_ld_value_a2[31] : FETCH_Instr_OriginalLd_ld_value_a2[15]) :
                                               ((FETCH_Instr_OriginalLd_addr_a2[1:0] == 2'b00) ? FETCH_Instr_OriginalLd_ld_value_a2[7] :
                                                (FETCH_Instr_OriginalLd_addr_a2[1:0] == 2'b01) ? FETCH_Instr_OriginalLd_ld_value_a2[15] :
                                                (FETCH_Instr_OriginalLd_addr_a2[1:0] == 2'b10) ? FETCH_Instr_OriginalLd_ld_value_a2[23] :
                                                                        FETCH_Instr_OriginalLd_ld_value_a2[31]
                                               )
                              );
                           assign {FETCH_Instr_OriginalLd_ld_rslt_a2[31:0], FETCH_Instr_OriginalLd_ld_mask_a2[3:0]} =
                                FETCH_Instr_OriginalLd_ld_st_word_a2 ? {FETCH_Instr_OriginalLd_ld_value_a2, 4'b1111} :
                                FETCH_Instr_OriginalLd_ld_st_half_a2 ? {{16{FETCH_Instr_OriginalLd_sign_bit_a2}}, FETCH_Instr_OriginalLd_addr_a2[1] ? {FETCH_Instr_OriginalLd_ld_value_a2[31:16], 4'b1100} :
                                                                           {FETCH_Instr_OriginalLd_ld_value_a2[15:0] , 4'b0011}} :
                                              {{24{FETCH_Instr_OriginalLd_sign_bit_a2}}, (FETCH_Instr_OriginalLd_addr_a2[1:0] == 2'b00) ? {FETCH_Instr_OriginalLd_ld_value_a2[7:0]  , 4'b0001} :
                                                                (FETCH_Instr_OriginalLd_addr_a2[1:0] == 2'b01) ? {FETCH_Instr_OriginalLd_ld_value_a2[15:8] , 4'b0010} :
                                                                (FETCH_Instr_OriginalLd_addr_a2[1:0] == 2'b10) ? {FETCH_Instr_OriginalLd_ld_value_a2[23:16], 4'b0100} :
                                                                                        {FETCH_Instr_OriginalLd_ld_value_a2[31:24], 4'b1000}};
                           `BOGUS_USE(FETCH_Instr_OriginalLd_ld_mask_a2) // It's only for formal verification.
                     // ISA-specific trap conditions:
                     // I can't see in the spec which of these is to commit results. I've made choices that make riscv-formal happy.
                     assign FETCH_Instr_non_aborting_isa_trap_a2 = (FETCH_Instr_branch_a2 && FETCH_Instr_taken_a2 && FETCH_Instr_misaligned_pc_a2) ||
                                              (FETCH_Instr_jump_a2 && FETCH_Instr_misaligned_jump_target_a2) ||
                                              (FETCH_Instr_indirect_jump_a2 && FETCH_Instr_misaligned_indirect_jump_target_a2);
                     assign FETCH_Instr_aborting_isa_trap_a2 =     (FETCH_Instr_ld_st_a2 && FETCH_Instr_unnatural_addr_trap_a2) ||
                                              FETCH_Instr_csr_trap_a2;
                     
                  //_@2
                     // Mux the correct result.
                     //_\source top.tlv 1361   // Instantiated from top.tlv, 1575 as: m4+riscv_rslt_mux_expr()
                        assign FETCH_Instr_rslt_a2[31:0] =
                            FETCH_Instr_returning_ld_a2 ? FETCH_Instr_OriginalLd_ld_rslt_a2 :
                            32'b0 |
                            ({32{FETCH_Instr_is_lui_instr_a2}} & FETCH_Instr_lui_rslt_a2) |
                            ({32{FETCH_Instr_is_auipc_instr_a2}} & FETCH_Instr_auipc_rslt_a2) |
                            ({32{FETCH_Instr_is_jal_instr_a2}} & FETCH_Instr_jal_rslt_a2) |
                            ({32{FETCH_Instr_is_jalr_instr_a2}} & FETCH_Instr_jalr_rslt_a2) |
                            ({32{FETCH_Instr_is_lb_instr_a2}} & FETCH_Instr_lb_rslt_a2) |
                            ({32{FETCH_Instr_is_lh_instr_a2}} & FETCH_Instr_lh_rslt_a2) |
                            ({32{FETCH_Instr_is_lw_instr_a2}} & FETCH_Instr_lw_rslt_a2) |
                            ({32{FETCH_Instr_is_lbu_instr_a2}} & FETCH_Instr_lbu_rslt_a2) |
                            ({32{FETCH_Instr_is_lhu_instr_a2}} & FETCH_Instr_lhu_rslt_a2) |
                            ({32{FETCH_Instr_is_addi_instr_a2}} & FETCH_Instr_addi_rslt_a2) |
                            ({32{FETCH_Instr_is_slti_instr_a2}} & FETCH_Instr_slti_rslt_a2) |
                            ({32{FETCH_Instr_is_sltiu_instr_a2}} & FETCH_Instr_sltiu_rslt_a2) |
                            ({32{FETCH_Instr_is_xori_instr_a2}} & FETCH_Instr_xori_rslt_a2) |
                            ({32{FETCH_Instr_is_ori_instr_a2}} & FETCH_Instr_ori_rslt_a2) |
                            ({32{FETCH_Instr_is_andi_instr_a2}} & FETCH_Instr_andi_rslt_a2) |
                            ({32{FETCH_Instr_is_slli_instr_a2}} & FETCH_Instr_slli_rslt_a2) |
                            ({32{FETCH_Instr_is_srli_srai_instr_a2}} & FETCH_Instr_srli_srai_rslt_a2) |
                            ({32{FETCH_Instr_is_add_sub_instr_a2}} & FETCH_Instr_add_sub_rslt_a2) |
                            ({32{FETCH_Instr_is_sll_instr_a2}} & FETCH_Instr_sll_rslt_a2) |
                            ({32{FETCH_Instr_is_slt_instr_a2}} & FETCH_Instr_slt_rslt_a2) |
                            ({32{FETCH_Instr_is_sltu_instr_a2}} & FETCH_Instr_sltu_rslt_a2) |
                            ({32{FETCH_Instr_is_xor_instr_a2}} & FETCH_Instr_xor_rslt_a2) |
                            ({32{FETCH_Instr_is_srl_sra_instr_a2}} & FETCH_Instr_srl_sra_rslt_a2) |
                            ({32{FETCH_Instr_is_or_instr_a2}} & FETCH_Instr_or_rslt_a2) |
                            ({32{FETCH_Instr_is_and_instr_a2}} & FETCH_Instr_and_rslt_a2) |
                            ({32{FETCH_Instr_is_csrrw_instr_a2}} & FETCH_Instr_csrrw_rslt_a2) |
                            ({32{FETCH_Instr_is_csrrs_instr_a2}} & FETCH_Instr_csrrs_rslt_a2) |
                            ({32{FETCH_Instr_is_csrrc_instr_a2}} & FETCH_Instr_csrrc_rslt_a2) |
                            ({32{FETCH_Instr_is_csrrwi_instr_a2}} & FETCH_Instr_csrrwi_rslt_a2) |
                            ({32{FETCH_Instr_is_csrrsi_instr_a2}} & FETCH_Instr_csrrsi_rslt_a2) |
                            ({32{FETCH_Instr_is_csrrci_instr_a2}} & FETCH_Instr_csrrci_rslt_a2);
                     //_\end_source
                  
               //_\end_source
            //_\end_source
            
            //_@1
               assign FETCH_Instr_pred_taken_branch_a1 = FETCH_Instr_pred_taken_a1 && FETCH_Instr_branch_a1;
            //_@2
   
               // =======
               // Control
               // =======
   
               // Execute stage redirect conditions.
               assign FETCH_Instr_aborting_trap_a2 = FETCH_Instr_illegal_a2 || FETCH_Instr_aborting_isa_trap_a2;
               assign FETCH_Instr_non_aborting_trap_a2 = FETCH_Instr_non_aborting_isa_trap_a2;
               assign FETCH_Instr_mispred_branch_a2 = FETCH_Instr_branch_a2 && ! (FETCH_Instr_conditional_branch_a2 && (FETCH_Instr_taken_a2 == FETCH_Instr_pred_taken_a2));
               //_?$valid_decode_branch
                  assign FETCH_Instr_branch_redir_pc_a2[31:2] =
                     // If fallthrough predictor, branch mispred always redirects taken, otherwise PC+1 for not-taken.
                     (! FETCH_Instr_taken_a2) ? FETCH_Instr_Pc_a2 + 30'b1 :
                     FETCH_Instr_branch_target_a2;
   
               assign FETCH_Instr_trap_target_a2[31:2] = 30'b0;  // TODO: What should this be?
               
               // Determine whether the instruction should commit it's result.
               //
               // Abort: Instruction triggers a condition causing a no-commit.
               // Commit: Ultimate decision to commit results of this instruction, considering aborts and
               //         prior-instruction redirects (good-path)
               //
               // Treatment of loads:
               //    Loads will commit. They write a garbage value and "pending" to the register file.
               //    Returning loads clobber an instruction. This instruction is $abort'ed (as is the
               //    returning load, since they are one in the same). Returning load must explicitly
               //    write results.
               //
               
               assign FETCH_Instr_abort_a2 = 1'b0 || FETCH_Instr_returning_ld_a2 || FETCH_Instr_replay_a2 || FETCH_Instr_aborting_trap_a2;  // Note that register bypass logic requires that abort conditions also redirect.
               // $commit = m4_valid_as_of(M4_NEXT_PC_STAGE + M4_MAX_REDIRECT_BUBBLES + 1), where +1 accounts for this
               // instruction's redirects. However, to meet timing, we consider this instruction separately, so,
               // commit if valid as of the latest redirect from prior instructions and not abort of this instruction.
               assign FETCH_Instr_commit_a2 = (! FETCH_Instr_reset_a2 && FETCH_Instr_next_good_path_mask_a0[(0 + 3) - 0]) && ! FETCH_Instr_abort_a2;
               
               // Conditions that commit results.
               assign FETCH_Instr_valid_dest_reg_valid_a2 = (FETCH_Instr_dest_reg_valid_a2 && FETCH_Instr_commit_a2) || FETCH_Instr_returning_ld_a2;
               assign FETCH_Instr_valid_ld_a2 = FETCH_Instr_ld_a2 && FETCH_Instr_commit_a2;
               assign FETCH_Instr_valid_st_a2 = FETCH_Instr_st_a2 && FETCH_Instr_commit_a2;
   
      //_\source top.tlv 1656   // Instantiated from top.tlv, 2041 as: m4+fixed_latency_fake_memory(/top, 0)
         // This macro assumes little-endian.
         
         //_|fetch
            //_/instr
               // ====
               // Load
               // ====
               //_@3
                  for (bank = 0; bank <= 4-1; bank++) begin : L1_FETCH_Instr_Bank wire [31:0] L1_addr_a3; wire [(32 / 4) - 1 : 0] L1_ld_value_a3; wire L1_spec_ld_a3; wire [3:0] L1_st_mask_a3; wire [31:0] L1_st_value_a3; wire L1_valid_st_a3; wire [(32 / 4) - 1 : 0] L1_Mem_Value_a3 [31:0]; //_/bank
                     assign {L1_addr_a3[31:0], L1_spec_ld_a3, L1_st_mask_a3[3:0], L1_st_value_a3[31:0], L1_valid_st_a3} = {FETCH_Instr_addr_a3, FETCH_Instr_spec_ld_a3, FETCH_Instr_st_mask_a3, FETCH_Instr_st_value_a3, FETCH_Instr_valid_st_a3}; // Find signal from outside of /bank.
                     //_/mem
                     //_?$spec_ld
                        assign L1_ld_value_a3[(32 / 4) - 1 : 0] = L1_Mem_Value_a3[L1_addr_a3[4 + 2 : 2]];
               
                     // Array writes are not currently permitted to use assignment
                     // syntax, so \always_comb is used, and this must be outside of
                     // when conditions, so we need to use if. <<1 because no <= support
                     // in this context. (This limitation will be lifted.)
      
                     // =====
                     // Store
                     // =====
      
                     /*SV_plus*/
                        always @ (posedge clk) begin
                           if (L1_valid_st_a3 && L1_st_mask_a3[bank])
                              L1_Mem_Value_a3[L1_addr_a3[4 + 2 : 2]][(32 / 4) - 1 : 0] <= L1_st_value_a3[(bank + 1) * (32 / 4) - 1: bank * (32 / 4)];
                        end end
                  // Combine $ld_value per bank, assuming little-endian.
                  //$ld_value[M4_WORD_RANGE] = /bank[*]$ld_value;
                  // Unfortunately formal verification tools can't handle multiple packed dimensions produced by the expression above, so we
                  // build the concatination.
                  assign FETCH_Instr_ld_value_a3[31:0] = {L1_FETCH_Instr_Bank[3].L1_ld_value_a3, L1_FETCH_Instr_Bank[2].L1_ld_value_a3, L1_FETCH_Instr_Bank[1].L1_ld_value_a3, L1_FETCH_Instr_Bank[0].L1_ld_value_a3};
      
         // Return loads in |mem pipeline. We just hook up the |mem pipeline to the |fetch pipeline w/ the
         // right alignment.
         //_|mem
            //_/data
               //_@3
                  assign {MEM_Data_addr_a3[1:0], MEM_Data_dest_reg_a3[4:0], MEM_Data_ld_st_half_a3, MEM_Data_ld_st_word_a3, MEM_Data_ld_value_a3[31:0], MEM_Data_raw_funct3_a3[2], MEM_Data_valid_ld_a3} = {FETCH_Instr_addr_a3[1:0], FETCH_Instr_dest_reg_a3, FETCH_Instr_ld_st_half_a3, FETCH_Instr_ld_st_word_a3, FETCH_Instr_ld_value_a3, FETCH_Instr_raw_funct3_a3[2], FETCH_Instr_valid_ld_a3};
                  for (src = 1; src <= 2; src++) begin : L1_MEM_Data_Src wire L1_dummy_a3; reg  L1_dummy_a4; //_/src
                     assign {L1_dummy_a3} = {L1b_FETCH_Instr_Src[src].L1_dummy_a3}; end
      //_\end_source
      //_|fetch
         //_/instr
            //_@3
               // =========
               // Reg Write
               // =========
   
               assign FETCH_Instr_reg_write_a3 = FETCH_Instr_reset_a3 ? 1'b0 : FETCH_Instr_valid_dest_reg_valid_a3;
               /*SV_plus*/
                  always @ (posedge clk) begin
                     if (FETCH_Instr_reg_write_a3)
                        FETCH_Instr_Regs_value_a3[FETCH_Instr_dest_reg_a3][31:0] <= FETCH_Instr_rslt_a3;
                  end
               
               // Write $pending along with $value, but coded differently because it must be reset.
               for (regs = 1; regs <= 31; regs++) begin : L1b_FETCH_Instr_Regs //_/regs
                  assign FETCH_Instr_Regs_pending_a2[regs] = ! FETCH_Instr_reset_a3 && (((regs == FETCH_Instr_dest_reg_a3) && FETCH_Instr_valid_dest_reg_valid_a3) ? FETCH_Instr_reg_wr_pending_a3 : FETCH_Instr_Regs_pending_a3[regs]); end
               
               
            //_@3
               `BOGUS_USE(L1_FETCH_Instr_OriginalLd_Src[2].L1_dummy_a3) // To pull $dummy through $ANY expressions, avoiding empty expressions.
   //_\end_source
   
   //_\source top.tlv 2064   // Instantiated from top.tlv, 2142 as: m4+tb()
      //_|fetch
         //_/instr
            //_@3
               // Assert these to end simulation (before Makerchip cycle limit).
               assign FETCH_Instr_ReachedEnd_a2 = FETCH_Instr_reset_a3 ? 1'b0 : FETCH_Instr_ReachedEnd_a3 || FETCH_Instr_Pc_a3 == {30{1'b1}};
               assign FETCH_Instr_Reg4Became45_a2 = FETCH_Instr_reset_a3 ? 1'b0 : FETCH_Instr_Reg4Became45_a3 || (FETCH_Instr_ReachedEnd_a3 && FETCH_Instr_Regs_value_a3[4] == 32'd45);
               assign passed = ! reset && FETCH_Instr_ReachedEnd_a3 && FETCH_Instr_Reg4Became45_a3;
               assign failed = ! reset && (cyc_cnt > 200 || (! FETCH_Instr_reset_a6 && FETCH_Instr_commit_a9 && FETCH_Instr_illegal_a9));
   endgenerate //_\end_source
   
//_\SV
   endmodule

